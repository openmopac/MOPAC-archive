subroutine to_screen(text) 
  use chanel_C, only : iw0
  use molkst_C, only : keywrd
  implicit none
  character (len=*) :: text
  integer :: i, j, version
  logical :: first=.true.
  save :: version
  if (text(:min(len_trim(text), 8)) /= "To_file:") then 
  if (iw0 > -1) then
  write(iw0,"(a)") text(:len_trim(text))
  call flush (iw0) 
  end if
  else 
  if (index(keywrd, " AUX") == 0) return
  if (first) then
  first = .false.
  version = 1
  i = index(keywrd, " AUX(")
  if (i /= 0) then  
    j = index(keywrd(i:),")") + i         
    if (index(keywrd(i:j), "V0") /= 0) then
      version = 0
    else
      version = 1
    end if
  end if
  end if
  select case (version)  
  case (0)  !  Original version (good up to May 2009) 
  call version0(text)
  case (1)  !  Current version (good up to the present)
  call current_version(text)
  end select
  end if


end subroutine to_screen
subroutine current_version (text)
  use chanel_C, only : output_fn
!
  use to_screen_C, only : rot, xyzmom, dip, dipt, travel, freq, &
  redmas, fcint, cnorml
!
  use common_arrays_C, only : nat, tvec, coord, nfirst, nlast, c, grad, &
  h, eigs, q, geo, na, nb, nc, p, pa, pb, eigb, cb, bondab, fmatrx, &
  txtatm, chrg, ipKa_sorted, pKa_sorted
!
  use parameters_C, only : zs, zp, zd, npq, betas, betap, betad, tore, natorb
!
  use symmetry_C, only : name, jndex, namo, state_spin, state_Irred_Rep, state_QN
!
  use polar_C, only : omega, alpavg
!
  use molkst_C, only : numat, norbs, escf, nelecs, elect, enuclr, verson, &
  method_am1, method_mndo, method_pm3, method_rm1, method_mndod, method_pm6, &
  nvar, koment, keywrd, zpe, id, density, natoms, formula, press, &
  uhf, nalpha, nbeta,  nclose, gnorm, mozyme, mol_weight, jloop => itemp_1, &
  line, nscf, time0, sz, ss2, no_pKa, title
!
  use MOZYME_C, only : ncf, ncocc, noccupied, icocc_dim, cocc_dim, nvirtual, icvir_dim, &
  nncf, iorbs, cocc, icocc, ncvir, nnce, nce, icvir, cvir, tyres, size_mres, &
  cvir_dim
!
  use elemts_C, only : elemnt
!
  use funcon_C, only : a0
!
  use cosmo_C, only : area, solv_energy, cosvol
!
  use meci_C, only : deltap, nmos, occa
!
  use maps_C, only : rxn_coord, rc_escf, ekin
!
  use second_I 
  use reada_I
  implicit none
  character (len=*) :: text
 
  integer :: i, j, k, l, hook = 50, if, im1, jj, ii, jf, ij, opt_hook, ni, nj, &
  norbi, norbj, kl, ku, i1, j1, ic, mos, moa_lower, moa_upper, &
  mob_lower, mob_upper
  logical :: normal, force, geom_opt, int_force_const, error, finished, &
  first = .true., LMO, LMO_alpha = .true., end_of_job, opend, compressed, &
  eigen, mullik, esp, irc_drc, irc, lnmoas, lnmobs, loc_mos, new_calcn = .true., &
  polar
  character :: atorbs(9)*2, idate*24, atoms*3, paras*3, orbs*3, orbs2*3, fmt*3, &
  fmt1*5
  double precision, dimension(3) :: convert = (/1.d0,57.29577951d0,57.29577951d0/)
  double precision :: work(norbs),  bi(9), bj(9), sum, limit, bk
  double precision, allocatable :: overlap(:), c_lmo(:), comp(:)
  double precision, allocatable :: overlap2(:,:)
  character, dimension(:), allocatable :: namo_tmp*4, letters*1
  character :: fmt8p4*5, fmt9p3*5, fmt9p4*5, fmt10p4*5, fmt9p5*5, fmt13p5*5, fmt13p6*5, &
  fmt7p4*5, irc_or_drc*1, num*1
  integer :: iwork(norbs), ifact(norbs + 1)
  integer, allocatable :: icomp(:)
  integer, external :: ijbo
  character, dimension (23) :: tyr
  save :: first, opt_hook, atoms, paras, orbs, compressed, fmt8p4, fmt9p3, fmt9p4, fmt10p4, &
  fmt9p5, fmt13p5, fmt13p6, fmt7p4, mos, irc, irc_or_drc, moa_lower, moa_upper, &
  mob_lower, mob_upper, lnmoas, lnmobs, loc_mos, new_calcn
  data atorbs/ ' S', 'PX', 'PY', 'PZ', 'X2', 'XZ', 'Z2', 'YZ', 'XY'/
  data tyr / "G", "A", "V", "L", "I", "S", "T", "D", "N", "K", "E", "Q", &
     & "R", "H", "F", "C", "W", "Y", "M", "P", "P", "P", "?" /

!
!   Take special action to output essential data in a compact ASCII form
!
  inquire(unit=hook, opened=opend) 
  if (.not. opend .or. new_calcn) then
    new_calcn = .false.
    if (index(text, "Leaving MOPAC") + index(text, "END_OF_JOB") /= 0) then
      new_calcn = .true.
      return
    end if
    open(unit=hook,file=output_fn(:len_trim(output_fn) - 4)//".aux")
    write(hook,"(a)")" START OF MOPAC FILE"
    write(hook,"(a)")" ####################################"
    write(hook,"(a)")" #                                  #"
    write(hook,"(a)")" #       Start of Input data        #"
    write(hook,"(a)")" #                                  #"
    write(hook,"(a)")" ####################################"
    write(hook,"(a,a)")" MOPAC_VERSION=MOPAC2009.",verson
    call fdate (idate) 
    write(hook,"(3a)")" DATE=""",idate,""""
    if (method_mndo) then
      write(hook,"(a)")" METHOD=MNDO"
    else if (method_am1) then
      write(hook,"(a)")" METHOD=AM1"
    else if (method_pm3) then
      write(hook,"(a)")" METHOD=AM1"
    else if (method_pm6) then
      write(hook,"(a)")" METHOD=PM6"
    else if (method_rm1) then
      write(hook,"(a)")" METHOD=RM1"
    else if (method_mndod) then
      write(hook,"(a)")" METHOD=MNDOD"
    end if
    line = koment
    if (len_trim(line) > 1) then
      do
        if (line(1:1) /= " ") exit
        line = line(2:)
      end do
    end if
    write(hook,"(a,a)")" TITLE=""",trim(line)//'"'
    line = keywrd
    do i = 1, len_trim(line)
      do
        if (line(i:i + 1) /= "  ") exit
        if (line(i:) == " ") exit
        line(i:) = line(i + 1:)
      end do
    end do   
    write(hook,"(a,a)")" KEYWORDS=""",trim(line)//'"' 
    line = title
    if (len_trim(line) > 0) then
      do
        if (line(1:1) /= " ") exit
        line = line(2:)
      end do
    end if
    write(hook,"(a,a)")" COMMENTS=""",trim(line)//'"' 
    if (numat < 334) then
      atoms = "4.4"
      paras = "4.4"
      orbs  = "4.4"
      orbs2 = "6.6"
    else
      atoms = "6.6"
      paras = "6.6"
      orbs  = "6.6"
      orbs2 = "8.8"
    end if 
    mos = 10
    i = index(keywrd, " AUX(")
    if (i /= 0) then          
      j = index(keywrd(i:),")") + i  
      k = i + 5
      if (ichar(keywrd(k:k)) >= ichar("0") .and. ichar(keywrd(k:k)) <= ichar("9")) then    
        opt_hook = nint(reada(keywrd(i:j),1))
        opt_hook = max(0, min(opt_hook,100))
      else
        opt_hook = hook
      end if
      compressed = (index(keywrd(i:j), "COMP") /= 0)
      k = index(keywrd(i:j), "MOS")
      if (k > 0) mos = nint(reada(keywrd(i:), k))
    else
      compressed = .false.
      opt_hook = hook
    end if
    if(index(keywrd," LARGE") == 0) then
        moa_lower = max(1, nclose - mos + 1, nalpha - mos + 1)
        moa_upper = min(norbs, max(nclose + mos, nalpha + mos))
        lnmoas = (moa_upper - moa_lower > -1)
        mob_lower = max(1, nclose - mos + 1, nalpha - mos + 1)
        mob_upper = min(norbs, max(nclose + mos, nalpha + mos))
        lnmobs = (mob_upper - mob_lower > -1)
      else
        moa_lower = 1
        moa_upper = norbs
        mob_lower = 1
        mob_upper = norbs
        lnmobs = .true.
        lnmoas = .true.
      end if  
    k = 0
    if (i > 0) k = index(keywrd(i:j), "PRECISION")
    if (k > 0) k = nint(reada(keywrd(i:), k))
    write(fmt7p4,"(i2.2,'.',i2.2)")7 + k, 4 + k  
    write(fmt8p4,"(i2.2,'.',i2.2)")8 + k, 4 + k    
    write(fmt9p3,"(i2.2,'.',i2.2)")9 + k, 3 + k 
    write(fmt9p4,"(i2.2,'.',i2.2)")9 + k, 4 + k 
    write(fmt9p5,"(i2.2,'.',i2.2)")9 + k, 5 + k   
    write(fmt10p4,"(i2.2,'.',i2.2)")10 + k, 4 + k 
    write(fmt13p5,"(i2.2,'.',i2.2)")13 + k, 5 + k  
    write(fmt13p6,"(i2.2,'.',i2.2)")13 + k, 6 + k        
  !
  !  All the data used in defining the starting system
  !
    write(hook,"(a,i"//atoms//",a)")" ATOM_EL[",numat,"]="
    write(hook,"(40(' ',a2))")(elemnt(nat(i)), i=1,numat)
    write(hook,"(a,i"//atoms//",a)")" ATOM_CORE[",numat,"]="
    write(hook,"(40(' ',i2))")(nint(tore(nat(i))), i=1,numat)
    write(hook,"(a,i"//paras//",a)")" ATOM_X:ANGSTROMS[",3*numat, "]="
    write(hook,"(3f"//fmt10p4//")") ((coord(j,i),j=1,3), i=1,numat)
    if (norbs > 0) then
      write(hook,"(a,i"//orbs//",a)")" AO_ATOMINDEX[",norbs,"]="
      write(hook,"(25i5)")((i,j = nfirst(i),nlast(i)), i = 1, numat)
      write(hook,"(a,i"//orbs//",a)")" ATOM_SYMTYPE[", norbs,"]="
      write(hook,"(40(' ',a2))")&
       ((atorbs(j - nfirst(i) + 1),j = nfirst(i),nlast(i)), i = 1, numat)
      write(hook,"(a,i"//orbs//",a)")" AO_ZETA[",norbs,"]="
  !
  !   Set up an array to hold all the atomic orbital exponents and principal quantum numbers
  !
      j = 1
      do i = 1, numat
        if (nlast(i) - nfirst(i) > -1) then
          work(j) = zs(nat(i))
          iwork(j) = npq(nat(i),1)
          j = j + 1
        end if
        if (nlast(i) - nfirst(i) > 2) then          
          work(j:j + 2) = zp(nat(i))
          iwork(j:j + 2) = npq(nat(i),2)
          j = j + 3
        end if
        if (nlast(i) - nfirst(i) > 7) then          
          work(j:j + 4) = zd(nat(i))
          iwork(j:j + 4) = npq(nat(i),3)
          j = j + 5
        end if
      end do
      write(hook,"(10f"//fmt8p4//")") (work(i), i=1,norbs)
      write(hook,"(a,i"//orbs//",a)")" ATOM_PQN[",norbs,"]="
      write(hook,"(40i2)")(iwork(i), i=1,norbs)
    end if
    if (norbs > 0) write(hook,"(a,i"//orbs//")")" NUM_ELECTRONS=",nelecs
    if (id > 0) then
      write(hook,"(a,i1,a)")" INITIAL_TRANS_VECTS:ANGSTROMS[",id*3,"]="
      write(hook,"(3f"//fmt9p4//")")((tvec(j,i),j=1,3),i=1,id)
      if (density > 1.d-1) write(hook,"(a,d"//fmt13p6//",a)")" DENSITY:G/CM^3=",density
    end if
    write(hook,"(a)")" EMPIRICAL_FORMULA="""//formula(31:len_trim(formula))//""""  
!
!  End of definition of starting system
!     
  end if
!
!  Set up options for various types of calculation
!
  geom_opt         = (index(text,"Geometry optimizing") /= 0)
  normal           = (index(text,"Normal output") /= 0)
  force            = (index(text,"Force output") /= 0)
  LMO              = (index(text,"LMO") /= 0)
  int_force_const  = (index(text,"Internal Force Constants") /= 0) 
  error            = (index(text,": ERROR:") /= 0) 
  finished         = (index(text,"Leaving MOPAC") /= 0) 
  end_of_job       = (index(text,"END_OF_JOB") /= 0) 
  mullik           = (index(text,"Mullik") /= 0) 
  esp              = (index(text,"Esp") /= 0) 
  irc_drc          = (index(text,"IRC-DRC") /= 0) 
  loc_mos          = (index(text,"Localized") /= 0)
  polar            = (index(text,"POLAR") /= 0)

  if (geom_opt) then
    if (first) then
      write(opt_hook,"(a)")" ####################################"
      write(opt_hook,"(a)")" #                                  #"
      write(opt_hook,"(a)")" #      Geometry optimization       #"
      write(opt_hook,"(a)")" #                                  #"
      write(opt_hook,"(a)")" ####################################"
      first = .false.
    end if
  !
  !  Geometry updated.
  !
    write(opt_hook,"(a,sp, d"//fmt13p6//",a)")" HEAT_OF_FORM_UPDATED:KCAL/MOL=",escf
    write(opt_hook,"(a,sp, d"//fmt13p6//",a)")" GRADIENT_UPDATED:KCAL/MOL/ANG=",gnorm
    write(opt_hook,"(a,i"//paras//",a)")" ATOM_X_UPDATED:ANGSTROMS[",3*numat, "]="
    write(opt_hook,"(3f"//fmt10p4//")") ((coord(j,i),j=1,3), i=1,numat)
    if (id > 0) then
      write(opt_hook,"(a,i1,a)")" TRANS_VECTS_UPDATED:ANGSTROMS[",id*3,"]="
      write(opt_hook,"(3f"//fmt9p4//")")((tvec(j,i),j=1,3),i=1,id)
      if (density > 1.d-1) write(opt_hook,"(a,d"//fmt13p6//",a)")" DENSITY:G/CM^3=",density
    end if
    if (opt_hook == 0) call flush (0) 
    return
  else if (irc_drc) then
    if (first) then
      if (index(keywrd, " DRC") == 0) then
        irc_or_drc = "I"
        irc = .true.
      else
        irc_or_drc = "D"
        irc = .false.
      end if
      write(opt_hook,"(a)")" ####################################"
      write(opt_hook,"(a)")" #                                  #"
      write(opt_hook,"(a)")" #               "//irc_or_drc//"RC                #"
      write(opt_hook,"(a)")" #                                  #"
      write(opt_hook,"(a)")" ####################################"
      first = .false.
    end if
  !
  !  Geometry updated.
  !
    write(opt_hook,"(a,i5.5)")" REF_POINT=",jloop
    write(opt_hook,"(a,sp, d"//fmt13p6//",a)")" MOVEMENT:ANGSTROMS=",rxn_coord
    write(opt_hook,"(a,sp, d"//fmt13p6//",a)")" POTENTIAL:KCAL/MOL=",rc_escf   
    if (irc) then       
      write(opt_hook,"(a,sp, d"//fmt13p6//",a)")" ENERGY_LOST:KCAL/MOL=",ekin        
    else
      write(opt_hook,"(a,sp, d"//fmt13p6//",a)")" KINETIC_ENERGY:KCAL/MOL=",ekin   
    end if
    write(opt_hook,"(a,i"//paras//",a)")" ATOM_X_UPDATED:ANGSTROMS[",3*numat, "]="
    write(opt_hook,"(3f"//fmt10p4//")") ((coord(j,i),j=1,3), i=1,numat)
    call print_conventional_M_O_s(opt_hook, compressed, moa_lower, moa_upper, mob_lower, mob_upper, fmt9p4, orbs2)
    call print_M_O_data(hook, moa_lower, moa_upper, lnmoas, mob_lower, mob_upper, lnmobs, orbs, fmt9p3)
    call chrge (p, q) 
    q(:numat) = tore(nat(:numat)) - q(:numat)
    write(opt_hook,"(a,i"//atoms//",a)")" ATOM_CHARGES[",numat,"]="
    write(opt_hook,"(sp,10f"//fmt9p5//")") (q(i), i=1,numat)
    if (opt_hook == 0) call flush (0) 
    return
  else if (normal) then !  Calculated results common to most types of calculation
    write(hook,"(a)")" ####################################"
    write(hook,"(a)")" #                                  #"
    write(hook,"(a)")" #        Final SCF results         #"
    write(hook,"(a)")" #                                  #"
    write(hook,"(a)")" ####################################"
  
    write(hook,"(a,sp, d"//fmt13p6//",a)")" HEAT_OF_FORMATION:KCAL/MOL=",escf
    write(hook,"(a,sp, d"//fmt13p6//",a)")" ENERGY_ELECTRONIC:EV=",elect
    write(hook,"(a,sp, d"//fmt13p6//",a)")" ENERGY_NUCLEAR:EV=",enuclr
    write(hook,"(a,sp, d"//fmt13p6//",a)")" GRADIENT_NORM:KCAL/MOL/ANGSTROM=",gnorm
    write(hook,"(a,a)")" POINT_GROUP=",name
    if (id > 0) then
      write(hook,"(a,i1,a)")" TRANS_VECTS:ANGSTROMS[",id*3,"]="
      write(hook,"(3f"//fmt9p4//")")((tvec(j,i),j=1,3),i=1,id)
      if (density > 1.d-1) write(hook,"(a,d"//fmt13p6//",a)")" DENSITY:G/CM^3=",density
      if (Abs(press(1)) > 1.d-20) then
        write(hook,"(a,i1,a)")" RESTRAINING_PRESSURE:GIGAPASCALS[3]="
        write(hook,"(3f"//fmt13p5//")")(press(i),i=1,3)
      end if
    end if
    if (Abs(dip(4,3)) > 1.d-20) then
      write(hook,"(a,sp, d"//fmt13p6//", a)")" DIPOLE:DEBYE=",dip(4,3)
      write(hook,"(a,sp, 3d"//fmt13p5//", a)")" DIP_VEC:DEBYE[3]=",(dip(i,3), i = 1, 3)
    end if
    if (no_pKa > 0) then
      num = char(ichar("1") +int(log10(ipKa_sorted(1) + 0.05)))
      write(hook,"(a,i"//num//")")" HYDROGEN_ATOM_NO_FOR_PKA=",ipKa_sorted(1)
      write(hook,"(a,sp, d"//fmt13p6//",a)")" PKA_OF_MOST_IONIZABLE_HYDROGEN=",pKa_sorted(1)
    end if
    if (area > 1.d-6) then
      write(hook,"(a,sp, d"//fmt13p6//",a)")" AREA:SQUARE ANGSTROMS=",area
      write(hook,"(a,sp, d"//fmt13p6//",a)")" VOLUME:CUBIC ANGSTROMS=",cosvol
      if (Abs(solv_energy) > 1.d-6) write(hook,"(a,sp, d"//fmt13p6//",a)")" DIEL_ENER:EV=",solv_energy
    end if
    write(hook,"(a,sp, d"//fmt13p6//",a)")" IONIZATION_POTENTIAL:EV=",-eigs(nelecs/2)
    write(hook,"(a,sp, d"//fmt13p6//",a)")" SPIN_COMPONENT=",sz
    write(hook,"(a,sp, d"//fmt13p6//",a)")" TOTAL_SPIN=",ss2
    num = char(ichar("1") +int(log10(nscf + 0.05)))
    write(hook,"(a,i"//num//")")" NUMBER_SCF_CYCLES=",nscf
    num = char(ichar("1") +int(log10(nalpha + 0.05)))
    write(hook,"(a,i"//num//")")" NUM_ALPHA_ELECTRONS=",nalpha
    num = char(ichar("1") +int(log10(nbeta + 0.05)))
    write(hook,"(a,i"//num//")")" NUM_BETA_ELECTRONS=",nbeta
      sum = second(1) - time0 
      i = int(sum*0.000001D0) 
      sum = sum - i*1000000 
    write(hook,"(a,sp, d"//fmt13p6//",a)")" CPU_TIME:SEC=",sum
    write(hook,"(a,sp, d"//fmt13p6//",a)")" MOLECULAR_WEIGHT:AMU=",mol_weight
    write(hook,"(a,sp, d"//fmt13p6//",a)")" TOTAL_ENERGY:EV=",elect + enuclr + solv_energy
    write(hook,"(a,i"//paras//",a)")" ATOM_X_OPT:ANGSTROMS[",3*numat, "]="
    write(hook,"(3f"//fmt10p4//")") ((coord(j,i),j=1,3), i=1,numat)
    write(hook,"(a,i"//atoms//",a)")" ATOM_CHARGES[",numat,"]="
    write(hook,"(sp,10f"//fmt9p5//")") (q(i), i=1,numat)
    if (nvar > 0) then
      sum = 0.d0
      do i = 1, nvar
        sum = sum + abs(grad(i))
      end do
      if (sum > 1.d-4) then
        write(hook,"(a,i"//paras//",a)")" GRADIENTS:KCAL/MOL/ANGSTROM[",nvar, "]="
        write(hook,"(10f"//fmt9p4//")") (grad(i), i=1,nvar)
      end if
    end if
  !
  ! Write out the residue letter, if it exists.
  !
    do i = 1, numat
      do j = 1, size_mres
        if (index(txtatm(i)(8:11), tyres(j)) > 0) exit
      end do
      if (j <= size_mres) exit
    end do
    if (i <= numat) then
      allocate(letters(numat))
      do i = 1, numat
        do j = 1, size_mres
           if (index(txtatm(i)(8:11), tyres(j)) > 0) exit
        end do
        if (j <= size_mres) then
          letters(i) = tyr(j)
        else
          letters(i) = "?"
        end if
      end do
      write(hook,"(a,i"//atoms//",a)")" RESIDUE_LETTER[",numat,"]="
      write(hook,"(100a1)")(letters(i), i = 1, numat)  
      deallocate(letters)
    end if
    if (mozyme) then
  !
  !   Start of MOZYME
  !
  !
  !  Set up an array to hold the overlap matrix
  !
        if (compressed) then
          write(hook,"(a)")" ####################################"
          write(hook,"(a)")" #                                  #"
          write(hook,"(a)")" #    Compressed Overlap Matrix     #"
          write(hook,"(a)")" #                                  #"
          write(hook,"(a)")" ####################################"
          write(hook,"(a)")" #  Lower half triangle only"
          limit = 0.05d0
          i = min(1000000, max(10000, 50*norbs))
          allocate(comp(i), icomp(i))
          ic = 0
        else
          write(hook,"(a,i"//orbs2//",a)")" OVERLAP_MATRIX[",(norbs*(norbs + 1))/2,"]="
          write(hook,"(a)")" #  Lower half triangle only"
          allocate(overlap2(norbs,9))
        end if
      do i = 1, numat
        overlap2 = 0.d0
        ii = iorbs(i)
        ni = nat(i) 
        bi = betas(ni)         
        bi(1) = betas(ni)*0.5D0 
        bi(2) = betap(ni)*0.5D0 
        bi(3) = bi(2) 
        bi(4) = bi(2) 
        bi(5) = betad(ni)*0.5D0 
        bi(6) = bi(5) 
        bi(7) = bi(5) 
        bi(8) = bi(5) 
        bi(9) = bi(5) 
        do j = 1, i - 1        
          jj = iorbs(j)
          if (i /= j .and. ijbo (i, j) >= 0) then
            nj = nat(j)
            bj(1) = betas(nj)*0.5D0 
            bj(2) = betap(nj)*0.5D0 
            bj(3) = bj(2) 
            bj(4) = bj(2) 
            bj(5) = betad(nj)*0.5D0 
            bj(6) = bj(5) 
            bj(7) = bj(5) 
            bj(8) = bj(5) 
            bj(9) = bj(5) 
            kl = ijbo (i, j)     ! starting address in H matrix  minus 1
            do i1 = 1, ii
              do j1 = 1, jj
                sum =h(kl + (i1 - 1)* jj + j1)/(bi(i1) + bj(j1))
                if (compressed) then
                  if (abs(sum) > limit) then
                    ic = ic + 1
                    k = nfirst(i) + i1 - 1
                    l = nfirst(j) + j1 - 1
                    icomp(ic) = (k*(k - 1))/2 + l
                    comp(ic) = sum
                  end if
                else
                  overlap2(j1 + nfirst(j) - 1, i1) = sum
                end if                  
              end do
            end do                 
          end if
        end do
  !
  ! Diagonal term
  ! 
        if (compressed) then
          do i1 = 1, ii
            k = nfirst(i) + i1 - 1
            ic = ic + 1
            icomp(ic) = (k*(k + 1))/2 
            comp(ic) = 1.d0
          end do 
        else
          do i1 = 1, ii
            overlap2(i1 + nfirst(j) - 1, i1) = 1.d0
          end do            
        end if            
  !
  ! At this point, overlap2 contains the entire overlap matrix for atom i up to atom i  
  !
        if (.not. compressed) then
          do i1 = 1,ii
            write(hook,"(10f"//fmt9p4//")") (overlap2(j1,i1), j1 = 1, nfirst(i) + i1 -1)
          end do  
        end if
      end do
      if (compressed) then
        if (ic < 999) then
          fmt = "3.3"
        else
          fmt = "6.6"
        end if
        if (norbs < 310) then
          fmt1 = "20i6"
        else if (norbs < 4470) then
          fmt1 = "15i8"
        else
          fmt1 = "10i12"
        end if
        write(hook,"(1x,a,i"//fmt//",a)")" COMPRESSED_OVERLAP_INDICES[",ic,"]="
        write(hook,"("//fmt1//")") (icomp(ii),ii=1,ic)
        write(hook,"(1x,a,i"//fmt//",a)")" COMPRESSED_OVERLAP_VALUES[",ic,"]="
        write(hook,"(10f"//fmt9p4//")") (comp(ii),ii=1,ic)
      end if
      if (index(keywrd, " BOND") /= 0) then
        if (compressed) then
          write(hook,"(a)")" ####################################"
          write(hook,"(a)")" #                                  #"
          write(hook,"(a)")" #     Compressed Bond Orders       #"
          write(hook,"(a)")" #                                  #"
          write(hook,"(a)")" ####################################"
          write(hook,"(a)")" #  Lower half triangle only"
          limit = 0.05d0
        else
          write(hook,"(a,i"//orbs2//",a)")" BOND_ORDERS[",(numat*(numat + 1))/2,"]="
          write(hook,"(a)")" #  Lower half triangle only"
        end if
        ic = 0
        do i = 1, numat
          ii = iorbs(i)
          do j = 1, i        
            jj = iorbs(j)
            if (i /= j .and. ijbo (i, j) >= 0) then 
              kl = ijbo (i, j) + 1
              ku = kl + ii * jj - 1
              sum = 0.d0
              do k = kl, ku
                sum = sum + p(k) ** 2
              end do
              if (compressed) then
                if (sum > limit) then
                  ic = ic + 1
                  comp(ic) = sum
                  icomp(ic) = (i*(i - 1))/2 + j
                end if
              else
                work(j) = sum
              end if
            end if
          end do
          if (.not. compressed) then
            work(i) = 0.d0
            write(hook,"(10f"//fmt9p4//")") (work(j), j=1, i)
          end if
        end do
        if (compressed) then
          if (ic < 999) then
            fmt = "3.3"
          else
            fmt = "6.6"
          end if
          if (numat < 310) then
            fmt1 = "20i6"
          else if (numat < 4470) then
            fmt1 = "15i8"
          else
            fmt1 = "10i12"
          end if
          write(hook,"(1x,a,i"//fmt//",a)")" COMPRESSED_BOND_ORDERS_INDICES[",ic,"]="
          write(hook,"("//fmt1//")") (icomp(ii),ii=1,ic)
          write(hook,"(1x,a,i"//fmt//",a)")" COMPRESSED_BOND_ORDERS_VALUES[",ic,"]="
          write(hook,"(10f"//fmt9p4//")") (comp(ii),ii=1,ic)
        end if
      end if  ! Bond orders       
      write(hook,"(a,2i8)")" SET_OF_MOS=",moa_lower, moa_upper 
      if (moa_lower > 1 .or. moa_upper < norbs) write(hook,"(a)") &
      " # To print all the molecular orbitals, add keyword LARGE or use MOS=99999 in AUX  #"    
      i = max(noccupied, nvirtual)
      allocate (c_lmo(norbs*i))
      eigen = (index(keywrd, " EIGEN") /= 0) 
      if (eigen) then
        call lmo_to_eigenvectors(noccupied, ncf, nncf, ncocc, noccupied, &
         & icocc, icocc_dim, cocc, cocc_dim, eigs, c_lmo)
        if (compressed) then
          do i = moa_lower, noccupied
            call write_comp_vect(hook, c_lmo((i - 1)*norbs + 1), norbs, 0.002d0, .true., &
            "EIGENVECTOR_INDICES","EIGENVECTOR_COEFFICIENTS", fmt9p4)
          end do
        else
          write(hook,"(a,i"//orbs2//",a)")" EIGENVECTORS[",norbs*(moa_upper - moa_lower + 1),"]="
          write(hook,"(10f"//fmt9p4//")") ((c_lmo(j + (i - 1)*norbs), j=1,norbs), i=moa_lower,noccupied)
        end if
        call lmo_to_eigenvectors(nvirtual, nce, nnce, ncvir, nvirtual, icvir, &
         & icvir_dim, cvir, cvir_dim, eigs(noccupied + 1), c_lmo)
        if (compressed) then
          do i = 1, moa_upper - noccupied
            call write_comp_vect(hook, c_lmo((i - 1)*norbs + 1), norbs, 0.002d0, .true., &
            "EIGENVECTOR_INDICES","EIGENVECTOR_COEFFICIENTS", fmt9p4)
          end do
        else
          write(hook,"(10f"//fmt9p4//")") ((c_lmo(j + (i - 1)*norbs), j=1,norbs), i= 1, moa_upper - noccupied)
        end if
      else
        if (compressed) then
        write(hook,"(a)")" ####################################"
        write(hook,"(a)")" #                                  #"
        write(hook,"(a)")" #     Compressed LMO vectors       #"
        write(hook,"(a)")" #                                  #"
        write(hook,"(a)")" ####################################"     
      else
        write(hook,"(a,i"//orbs2//",a)")" LMO_VECTORS[",norbs*(moa_upper - moa_lower +1),"]="
      end if
      do i = moa_lower, noccupied
  !
  ! Expand i'th LMO into uncompressed format
  !
        c_lmo = 0.d0
        ii = ncocc(i)
        do j = nncf(i) + 1, nncf(i) + ncf(i)
          jj = icocc(j)
          do k = nfirst(jj), nlast(jj)
            ii = ii + 1
            c_lmo(k) = cocc(ii)
          end do
        end do
        if (compressed) then
          call write_comp_vect(hook, c_lmo, norbs, 0.002d0, .true., &
            "LMO_INDICES","LMO_COEFFICIENTS", fmt9p4)
        else
          write(hook,"(10f"//fmt9p4//")") (c_lmo(j), j=1,norbs)
        end if
      end do
      do i = 1, moa_upper - noccupied 
  !
  ! Expand i'th LMO into uncompressed format
  !
        c_lmo = 0.d0
        ii = ncvir(i)
        do j = nnce(i) + 1, nnce(i) + nce(i)
          jj = icvir(j)
          do k = nfirst(jj), nlast(jj)
            ii = ii + 1
            c_lmo(k) = cvir(ii)
          end do
        end do
        if (compressed) then
            call write_comp_vect(hook, c_lmo, norbs, 0.002d0, .true., &
            "LMO_INDICES","LMO_COEFFICIENTS", fmt9p4)
          else
            write(hook,"(10f"//fmt9p4//")") (c_lmo(j), j=1,norbs)
          end if
        end do
      end if
      
      if (compressed) then
        write(hook,"(a)")" ####################################"
        write(hook,"(a)")" #                                  #"
        write(hook,"(a)")" #    Compressed Density Matrix     #"
        write(hook,"(a)")" #                                  #"
        write(hook,"(a)")" ####################################"
        write(hook,"(a)")" #  Lower half triangle only"
        limit = 0.05d0
        ic = 0
      else
        write(hook,"(a,i"//orbs2//",a)")" DENSITY_MATRIX[",(norbs*(norbs + 1))/2,"]="
        write(hook,"(a)")" #  Lower half triangle only"
      end if
      do i = 1, numat
        overlap2 = 0.d0
        ii = iorbs(i)
        do j = 1, i - 1        
          jj = iorbs(j)
          if (i /= j .and. ijbo (i, j) >= 0) then
            ij = ijbo (i, j)     ! starting address in P matrix  minus 1
            do i1 = 1, ii
              do j1 = 1, jj
                sum = p(ij + ((i1 - 1)*i1)/2 + j1)
                if (compressed) then
                  if (abs(sum) > limit) then
                    ic = ic + 1
                    k = nfirst(i) + i1 - 1
                    l = nfirst(j) + j1 - 1
                    icomp(ic) = (k*(k - 1))/2 + l
                    comp(ic) = sum
                  end if
                else
                  overlap2(j1 + nfirst(j) - 1, i1) = sum
                end if   
              end do
            end do                 
          end if
        end do
  !
  ! Diagonal term
  ! 
        ij = ijbo (i, i)
        do i1 = 1, ii
          do j1 = 1, i1
            sum = p(ij + ((i1 - 1)*i1)/2 + j1)
            if (compressed) then
              if (abs(sum) > limit) then
                ic = ic + 1
                k = nfirst(i) + i1 - 1
                l = nfirst(j) + j1 - 1
                icomp(ic) = (k*(k - 1))/2 + l
                comp(ic) = sum
              end if
            else
              overlap2(j1 + nfirst(j) - 1, i1) = sum
            end if              
          end do
        end do            
  !
  ! At this point, overlap2 contains the entire density matrix for atom i up to atom i  
  !
        if ( .not. compressed) then
          do i1 = 1,ii
            write(hook,"(10f"//fmt9p4//")") (overlap2(j1,i1), j1 = 1, nfirst(i) + i1 -1)
          end do  
        end if
      end do
      if (compressed) then
        if (ic < 999) then
          fmt = "3.3"
        else
          fmt = "6.6"
        end if
        if (norbs < 310) then
          fmt1 = "20i6"
       else if (norbs < 4470) then
          fmt1 = "15i8"
        else
          fmt1 = "10i12"
        end if
        write(hook,"(1x,a,i"//fmt//",a)")" COMPRESSED_DENSITY_INDICES[",ic,"]="
        write(hook,"("//fmt1//")") (icomp(ii),ii=1,ic)
        write(hook,"(1x,a,i"//fmt//",a)")" COMPRESSED_DENSITY_VALUES[",ic,"]="
        write(hook,"(10f"//fmt9p4//")") (comp(ii),ii=1,ic)
      end if
      if (eigen) then
        write(hook,"(a,i"//orbs//",a)")" EIGENVALUES[",moa_upper - moa_lower + 1,"]="
      else
        write(hook,"(a,i"//orbs//",a)")" LMO_ENERGY_LEVELS[",moa_upper - moa_lower + 1,"]="
      end if
      write(hook,"(10f"//fmt9p3//")") (eigs(i), i=moa_lower,moa_upper)  
      if (compressed) then
        deallocate (icomp, comp, c_lmo)
      else
        deallocate (overlap2, c_lmo)
      end if
  !
  !   End of MOZYME part
  !
    else
  !
  !   Conventional matrix-algebra method
  !
  !
  !  Set up an array to hold the overlap matrix
  !
      do i = 1, norbs 
        ifact(i) = (i*(i - 1))/2 
      end do 
      ifact(norbs+1) = (norbs*(norbs + 1))/2 
      allocate(overlap((norbs*(norbs + 1))/2))
      overlap = 0.d0
      do i = 1, numat 
        if = nfirst(i) 
        im1 = i - 1 
        ni = nat(i) 
        bi = betas(ni)         
        bi(1) = betas(ni)*0.5D0 
        bi(2) = betap(ni)*0.5D0 
        bi(3) = bi(2) 
        bi(4) = bi(2) 
        bi(5) = betad(ni)*0.5D0 
        bi(6) = bi(5) 
        bi(7) = bi(5) 
        bi(8) = bi(5) 
        bi(9) = bi(5) 
        norbi = natorb(ni)    
        do j = 1, im1 
          nj = nat(j)
          bj(1) = betas(nj)*0.5D0 
          bj(2) = betap(nj)*0.5D0 
          bj(3) = bj(2) 
          bj(4) = bj(2) 
          bj(5) = betad(nj)*0.5D0 
          bj(6) = bj(5) 
          bj(7) = bj(5) 
          bj(8) = bj(5) 
          bj(9) = bj(5) 
          norbj = natorb(nj) 
          jf = nfirst(j) 
          do ii = 1, norbi
            do jj = 1, norbj
              ij = ((if + ii - 1)*(if + ii - 2))/2 + jf + jj - 1
              overlap(ij) = h(ij)/(bi(ii) + bj(jj))
            end do
          end do
        end do 
      end do 
      overlap(ifact(2:norbs+1)) = 1.D0 
      if (compressed) then
        call write_comp_vect(hook, overlap, ((norbs*(norbs + 1))/2), 0.0001d0, .false., &
        "OVERLAP_INDICES","OVERLAP_COEFFICIENTS", fmt9p4)
      else
        write(hook,"(a,i"//orbs2//",a)")" OVERLAP_MATRIX[",(norbs*(norbs + 1))/2,"]="
        write(hook,"(a)")" #  Lower half triangle only"
        write(hook,"(10f"//fmt9p4//")") (overlap(i), i=1,(norbs*(norbs + 1))/2)
      end if
      deallocate (overlap) 
      
      call print_conventional_M_O_s(hook, compressed, moa_lower, moa_upper, mob_lower, mob_upper, fmt9p4, orbs2)
     
      if (uhf) then
        if (compressed) then
          call write_comp_vect(hook, pa, ((norbs*(norbs + 1))/2), 0.0005d0, .false., &
            "ALPHA_DENSITY_MATRIX_INDICES","ALPHA_DENSITY_MATRIX_COEFFICIENTS", fmt9p4)
          call write_comp_vect(hook, pb, ((norbs*(norbs + 1))/2), 0.0005d0, .false., &
            "BETA_DENSITY_MATRIX_INDICES","BETA_DENSITY_MATRIX_COEFFICIENTS", fmt9p4)
        else
          write(hook,"(a,i"//orbs2//",a)")" ALPHA_DENSITY_MATRIX[",(norbs*(norbs + 1))/2,"]="
          write(hook,"(a)")" #  Lower half triangle only"
          write(hook,"(10f"//fmt9p4//")") (pa(i), i=1,(norbs*(norbs + 1))/2)
          write(hook,"(a,i"//orbs2//",a)")" BETA_DENSITY_MATRIX[",(norbs*(norbs + 1))/2,"]="
          write(hook,"(a)")" #  Lower half triangle only"
          write(hook,"(10f"//fmt9p4//")") (pb(i), i=1,(norbs*(norbs + 1))/2)
        end if
      else     
        if (compressed) then
          call write_comp_vect(hook, p, ((norbs*(norbs + 1))/2), 0.0005d0, .false., &
            "DENSITY_MATRIX_INDICES","DENSITY_MATRIX_COEFFICIENTS", fmt9p4)
        else
          write(hook,"(a,i"//orbs2//",a)")" TOTAL_DENSITY_MATRIX[",(norbs*(norbs + 1))/2,"]="
          write(hook,"(a)")" #  Lower half triangle only"
          write(hook,"(10f"//fmt9p4//")") (p(i), i=1,(norbs*(norbs + 1))/2)
        end if
      end if
      if (index(keywrd, " BOND") /= 0) then
        if (.not. allocated(bondab))  call bonds () 
        if (compressed) then
          do i = 1, numat
  !
  !  Work out all bond orders involving atom i
  !
            ic = 0
            do j = 1, numat
              if (i == j) cycle
              ii = min(i, j)  
              jj = max(i, j)    
              sum = bondab((jj*(jj - 1))/2 + ii)
              if (sum > 0.05d0) then
                ic = ic + 1
                comp(ic) = sum
                icomp(ic) = j
              end if
            end do
          end do
          if (ic < 999) then
            fmt = "3.3"
          else
            fmt = "6.6"
          end if
          if (numat < 310) then
            fmt1 = "20i6"
          else if (numat < 4470) then
            fmt1 = "15i8"
          else
            fmt1 = "10i12"
          end if
          write(hook,"(1x,a,i"//fmt//",a)")" COMPRESSED_BOND_ORDERS_INDICES[",ic,"]="
          write(hook,"("//fmt1//")") (icomp(ii),ii=1,ic)
          write(hook,"(1x,a,i"//fmt//",a)")" COMPRESSED_BOND_ORDERS_VALUES[",ic,"]="
          write(hook,"(10f"//fmt9p4//")") (comp(ii),ii=1,ic)
        else        
          write(hook,"(a,i"//orbs2//",a)")" BOND_ORDERS[",(numat*(numat + 1))/2,"]="
          write(hook,"(a)")" #  Lower half triangle only"
          write(hook,"(10f"//fmt9p4//")") (bondab(i), i=1,(numat*(numat + 1))/2)
        end if
      end if
      call print_M_O_data(hook, moa_lower, moa_upper, lnmoas, mob_lower, mob_upper, lnmobs, orbs, fmt9p3)
    end if
  !
  !   Molecular orbital occupancies
  !
    if (uhf) then
      if (lnmoas) then
        write(hook,"(a,i5.5,a)")" ALPHA_MOLECULAR_ORBITAL_OCCUPANCIES[",moa_upper - moa_lower + 1,"]="
        write(hook,"(40i2)")(1, i = moa_lower, nalpha),(0, i = nalpha + 1, moa_upper)
      end if
      if (lnmobs) then
        write(hook,"(a,i5.5,a)")" BETA_MOLECULAR_ORBITAL_OCCUPANCIES[",mob_upper - mob_lower + 1,"]="
        write(hook,"(40i2)")(1, i = mob_lower, nbeta),(0, i = nbeta + 1, mob_upper)
      end if
    else
      if (nmos == 0) then
        if (lnmoas) then
  !
  !   Simple closed shell RHF
  !
          write(hook,"(a,i5.5,a)")" MOLECULAR_ORBITAL_OCCUPANCIES[",moa_upper - moa_lower + 1,"]="
          write(hook,"(10f"//fmt7p4//")")(2.d0, i = moa_lower, nclose),(0.d0, i = nclose + 1, moa_upper)
        end if
      else
        if (lnmoas) then
  !
  !   RHF-C.I.: Recalculate M.O. occupancies of the active space
  !
          write(hook,"(a,i5.5,a)")" MOLECULAR_ORBITAL_OCCUPANCIES[",moa_upper - moa_lower + 1,"]="      
          if (nclose > 0) then
            write(hook,"(a)")" #  Below active space"
            write(hook,"(10f"//fmt7p4//")")(2.d0, i = moa_lower, nclose)
            write(hook,"(a)")" #  Active space"
            write(hook,"(10f"//fmt7p4//")")(2.d0*occa(i) + deltap(i,i), i = 1, nmos)
            if (nclose + nmos + 1 <= norbs) then
              write(hook,"(a)")" #  Above active space"
              write(hook,"(10f"//fmt7p4//")")(0.d0, i = nclose + nmos + 1, moa_upper)
            end if
          end if
        end if
        write(hook,'(''STATE="'',i2,1x,3A)') state_QN, state_spin, &
        state_Irred_Rep(:len_trim(state_Irred_Rep))//'"'       
      end if
    end if
    
    if (LMO) then
      if (uhf) then
        if (LMO_alpha) then
          LMO_alpha = .false.
          write(hook,"(a,i"//orbs2//",a)")" ALPHA_LMO_MO[",norbs*nalpha,"]="
          write(hook,"(10f"//fmt9p4//")") ((c(j,i), j=1,norbs), i=1,nalpha)
          write(hook,"(a,i"//orbs//",a)")" ALPHA_LMO_E[",nalpha,"]="
        write(hook,"(10f"//fmt9p3//")") (eigs(i), i=1,nalpha)
        else
          write(hook,"(a,i"//orbs2//",a)")" BETA_LMO_MO[",norbs*nbeta,"]="
          write(hook,"(10f"//fmt9p4//")") ((cb(j,i), j=1,norbs), i=1,nbeta)
          write(hook,"(a,i"//orbs//",a)")" BETA_LMO_E[",nbeta,"]="
        write(hook,"(10f"//fmt9p3//")") (eigb(i), i=1,nbeta)
        end if       
      else
        write(hook,"(a,i"//orbs2//",a)")" LMO_MO[",norbs*nclose,"]="
        write(hook,"(10f"//fmt9p4//")") ((c(j,i), j=1,norbs), i=1,nclose)
        write(hook,"(a,i"//orbs//",a)")" LMO_E[",nclose,"]="
        write(hook,"(10f"//fmt9p3//")") (eigs(i), i=1,nclose)
      end if
    end if
  else if (mullik) then
    write(hook,"(a,i"//atoms//",a)")" MULLIKEN_ATOM_CHARGES[",numat,"]="
    write(hook,"(sp,10f9.5)") (chrg(i), i=1,numat)
  else if (esp) then
    write(hook,"(a,i"//atoms//",a)")" ELECTOSTATIC_POTENTIAL_CHARGES[",numat,"]="
    write(hook,"(sp,10f9.5)") (q(i), i=1,numat)
  else if (loc_mos) then
    if (uhf) then
      if ((index(text,"alpha") /= 0)) then
        write(hook,"(a,i"//orbs2//",a)")" ALPHA_LMO_MO[",norbs*nalpha,"]="
        write(hook,"(10f"//fmt9p4//")") ((c(j,i), j=1,norbs), i=1,nalpha)
        write(hook,"(a,i"//orbs//",a)")" ALPHA_LMO_E[",nalpha,"]="
      write(hook,"(10f"//fmt9p3//")") (eigs(i), i=1,nalpha)
      else
        write(hook,"(a,i"//orbs2//",a)")" BETA_LMO_MO[",norbs*nbeta,"]="
        write(hook,"(10f"//fmt9p4//")") ((cb(j,i), j=1,norbs), i=1,nbeta)
        write(hook,"(a,i"//orbs//",a)")" BETA_LMO_E[",nbeta,"]="
      write(hook,"(10f"//fmt9p3//")") (eigb(i), i=1,nbeta)
      end if       
    else
      write(hook,"(a,i"//orbs2//",a)")" LMO_MO[",norbs*nclose,"]="
      write(hook,"(10f"//fmt9p4//")") ((c(j,i), j=1,norbs), i=1,nclose)
      write(hook,"(a,i"//orbs//",a)")" LMO_E[",nclose,"]="
      write(hook,"(10f"//fmt9p3//")") (eigs(i), i=1,nclose)
    end if
  else if(force) then
    write(hook,"(a)")" ####################################"
    write(hook,"(a)")" #                                  #"
    write(hook,"(a)")" #      Normal mode analysis        #"
    write(hook,"(a)")" #                                  #"
    write(hook,"(a)")" ####################################"
    write(hook,"(a,i"//paras//",a)")" ORIENTATION_ATOM_X:ANGSTROMS[",3*numat, "]="
    write(hook,"(3f"//fmt10p4//")") ((coord(j,i),j=1,3), i=1,numat)
    write(hook,"(a,3f"//fmt13p6//",a)")" ROTAT_CONSTS:CM(-1)[3]=",rot
    write(hook,"(a,3f"//fmt13p6//",a)")" PRI_MOM_OF_I:10**(-40)*GRAM-CM**2[3]",xyzmom
    write(hook,"(a,f"//fmt13p6//",a)")" ZERO_POINT_ENERGY:KCAL/MOL=",zpe
    write(hook,"(a,i"//paras//",a)")" VIB._FREQ:CM(-1)[", nvar, "]="
    write(hook,"(10f9.2)") (freq(i), i=1,nvar)     
    if (compressed) then
      do i = 1, nvar
         call write_comp_vect(hook, cnorml((i - 1)*3*numat + 1), 3*numat, 0.0005d0, .false., &
            "NORMAL_MODE_INDICES","NORMAL_MODE_COEFFICIENTS", fmt9p4)
      end do       
    else
      write(hook,"(a,i"//orbs2//",a)")" NORMAL_MODES[",3*nvar*numat,"]="
      write(hook,"(10f"//fmt9p4//")") (cnorml(i),i = 1,3*nvar*numat)
    end if
    j = (3*numat*(3*numat + 1))/2
    if (compressed) then
      write(hook,"(a)")" #COMPRESSED_HESSIAN_MATRIX:MILLIDYNES/ANGSTROM"
      call write_comp_vect(hook, fmatrx, j, 0.0001d0, .false., &
        "HESSIAN_INDICES","HESSIAN_COEFFICIENTS", fmt9p4)
    else        
      write(hook,"(a,i"//orbs2//",a)")" HESSIAN_MATRIX:MILLIDYNES/ANGSTROM[",j,"]="
      write(hook,"(a)")" #  Lower half triangle only"
      write(hook,"(10f"//fmt9p4//")") (fmatrx(i), i=1,j)
    end if
    if (jndex(1) == 1) then
      allocate(namo_tmp(nvar))
      namo_tmp = namo
      do i = 1,nvar
        j = index(namo_tmp(i),'"')
        if (j /= 0) namo_tmp(i) = namo(i)(:j - 1)//"''"
      end do
      write(hook,"(a,i"//paras//",a)")" NORMAL_MODE_SYMMETRY_LABELS[",nvar,"]="
      write(hook,'(10(i4,a4))') (jndex(i),namo_tmp(i), i=1,nvar)
      deallocate(namo_tmp)
    end if
    write(hook,"(a,i"//paras//",a)")" VIB._T_DIP:ELECTRONS[", nvar, "]="
    write(hook,"(10f"//fmt9p3//")") (dipt(i), i=1,nvar)
    write(hook,"(a,i"//paras//",a)")" VIB._TRAVEL:ANGSTROMS[", nvar, "]= "
    write(hook,"(10f"//fmt9p3//")") (travel(i), i=1,nvar)
    write(hook,"(a,i"//paras//",a)")" VIB._RED_MASS:AMU[", nvar, "]= "
    write(hook,"(10f"//fmt9p3//")") (redmas(i, 1), i=1,nvar)
    write(hook,"(a,i"//paras//",a)")" VIB._EFF_MASS:AMU[", nvar, "]= "
    write(hook,"(10f"//fmt9p3//")") (min(9999.999d0, max(-999.999d0, redmas(i, 2))), i=1,nvar)
    write(hook,"(a,i"//paras//",a)")" ATOM_X_FORCE:ANGSTROMS[",3*numat, "]="
    write(hook,"(3f"//fmt10p4//")") ((coord(j,i),j=1,3), i=1,numat)
  else if (int_force_const) then
    write(hook,"(a,i"//paras//",a)")" INT_FORCE_CONSTS:MILLIDYNES/ANGSTROM[",3*numat, "]= "
    write(hook,"(3f"//fmt10p4//")") ((fcint(j,i),j=1,3), i=1,numat) 
    j = 0
    do i = 2, natoms
      if (na(i) /= 0) j = j + 1
    end do
    if (j /= 0) then
      write(hook,"(a,i"//paras//",a)")" INT_COORDS:ANGSTROMS AND DEGREES[",3*numat, "]="
      do i = 1, natoms
        if (na(i) == 0) then
          write(hook,"(3f"//fmt10p4//")") (geo(j,i),j=1,3)
        else
          write(hook,"(3f"//fmt10p4//")") (geo(j,i)*convert(j),j=1,3)
        end if
      end do
      write(hook,"(a,i"//paras//",a)")" CONNECTIVITY[",3*numat, "]="
      write(hook,"(3i5)")(na(i), nb(i), nc(i), i = 1, natoms)
    end if
  else if (error) then
    write(hook,"(a,a)")" ERROR=""",text(17:len_trim(text))//""""
  else if (polar) then
    write(hook,"(a,sp, d"//fmt13p6//", a)")" POLAR_FREQUENCY:EV=",omega
    write(hook,"(a,sp, d"//fmt13p6//", a)")" POLAR_AVE_ALPHA:CUBIC ANGSTROMS=", alpavg*a0**3

  else if (end_of_job) then
    if (index(text,"JOB ENDED NORM") /= 0) then
      write(hook,"(a,a)")" TERMINATION_MESSAGE=""",text(19:len_trim(text))//'"'
    else
      write(hook,"(a,a)")" ERROR_MESSAGE=""",text(19:len_trim(text))//'"'
    end if
  else if (finished) then
    write(hook,"(a,f12.2)")" CPU_TIME:SECONDS[1]=",time0
!
!  Don't print processor-independent CPU times for quick jobs - that would waste too much time.
! 
    if (time0 > 1.d0) then
!
!  Deliberately run a time-consuming calculation to work out CPU speed
!  The "j" index is set to use up 1.0 seconds on the development computer.
!  Do NOT change this quantity!
!
      bk = second(2)
      bi = 0.d0
      do j = 1,142083
        do i = 1,1000
          bi = bi + 1.d0/i
        end do
      end do
      bk = second(2) - bk 
      write(hook,"(a,f12.2)")" CPU_TIME:ARBITRARY_UNITS[1]=",time0/bk
    end if
    write(hook,"(a)")" END OF MOPAC FILE"
    new_calcn = .true.
  end if  
  return
end subroutine current_version
subroutine write_comp_vect(output, c, size_c, cutoff, norm, text1, text2, fmt9p4)
!
!  Write out the vector "c" in compressed form
!
  implicit none
  integer, intent(in) :: output, size_c
  logical, intent (in) :: norm
  double precision, intent(in) :: c(size_c), cutoff
  character (len=*), intent (in) :: text1, text2 
  character, intent (in) :: fmt9p4*5
  integer :: n, ii, j, k
  double precision :: c_loc(size_c), c1(size_c), sum, phase
  integer :: ivec(size_c), ic(size_c)
  character :: fmt*3
  n = 0
  do j = 1,size_c
  if (Abs(c(j)) > cutoff) then
    n = n + 1
    ivec(n) = j
    c_loc(n) = c(j)          
  end if
  end do
!
!  Re-sequence the coefficients so that the largest is first
!
  do ii = 1, n
  sum = 0.d0
  do j = 1, n
    if (sum < Abs(c_loc(j))) then
      sum = Abs(c_loc(j))
      k = j
    end if
  end do
  ic(ii) = ivec(k)
  c1(ii) = c_loc(k)
  c_loc(k) = 0.d0
  end do
  if (norm) then
  sum = 0.d0
  do j = 1, n
    sum = sum + c1(j)**2
  end do
  phase = 1.d0/sqrt(sum)
  if (c1(1) < 0.d0) phase = -phase
  else
  phase = 1.d0
  end if
!
!  Write out all finite indices.
!
  if (n < 999) then
  fmt = "3.3"
  else
  fmt = "6.6"
  end if
  write(output,"(1x,a,i"//fmt//",a)")trim(text1)//"[",n,"]="
  write(output,"(20i6)") (ic(ii),ii=1,n)
  write(output,"(1x,a,i"//fmt//",a)")trim(text2)//"[",n,"]="
  write(output,"(10f"//fmt9p4//")") (phase*c1(ii),ii=1,n)
  return
end subroutine write_comp_vect





subroutine version0(text)
  use chanel_C, only : iw0, output_fn
!
  use to_screen_C, only : rot, xyzmom, dip, dipt, travel, freq, &
  redmas, fcint, cnorml
!
  use common_arrays_C, only : nat, tvec, coord, nfirst, nlast, c, grad, &
  eigs, q, geo, na, nb, nc, p, pa, pb, eigb, cb, bondab, fmatrx, &
  txtatm
!
  use parameters_C, only : zs, zp, zd, npq, tore
!
  use symmetry_C, only : name, jndex, namo, state_spin, state_Irred_Rep, state_QN
!
  use molkst_C, only : numat, norbs, escf, nelecs, elect, enuclr, verson, &
  method_am1, method_mndo, method_pm3, method_rm1, method_mndod, method_pm6, &
  nvar, koment, keywrd, zpe, id, density, natoms, formula, press, time0, &
  uhf, nalpha, nbeta,  nclose, gnorm, line, mozyme
!
  use MOZYME_C, only : ncf, ncocc, noccupied, nvirtual, &
  nncf, iorbs, cocc, icocc, ncvir, nnce, nce, icvir, cvir, tyres, size_mres
!
  use elemts_C, only : elemnt
!
  use cosmo_C, only : area, solv_energy, cosvol
!
  use meci_C, only : deltap, nmos, occa
!
  use second_I 
  use reada_I
  implicit none
  character (len=*) :: text
  integer :: i, j, k, l, n, hook = 50, jj, ii, opt_hook, kl, ku
  logical :: normal, force, geom_opt, int_force_const, error, finished, &
  first = .true., LMO, LMO_alpha = .true., end_of_job, opend
  character :: atorbs(9)*2, idate*24, atoms*3, paras*3, orbs*3, orbs2*3
  double precision, dimension(3) :: convert = (/1.d0,57.29577951d0,57.29577951d0/)
  double precision :: work(norbs),  bi(9), bj(9), sum, phase
  double precision, allocatable :: overlap(:), c_lmo(:), c1(:)
  integer, allocatable :: ivec(:), ic(:)
  character, dimension(:), allocatable :: namo_tmp*4, letters*1
  integer :: iwork(norbs)
  integer, external :: ijbo
  character, dimension (23) :: tyr
  save :: first, opt_hook, atoms, paras, orbs
  data atorbs/ ' S', 'PX', 'PY', 'PZ', 'X2', 'XZ', 'Z2', 'YZ', 'XY'/
  data tyr / "G", "A", "V", "L", "I", "S", "T", "D", "N", "K", "E", "Q", &
     & "R", "H", "F", "C", "W", "Y", "M", "P", "P", "P", "?" /
  if (text(:min(len_trim(text), 8)) /= "To_file:") then
  if (iw0 > -1) then
  write(iw0,"(a)") text(:len_trim(text))
  call flush (iw0) 
  end if
  else 
  if (index(keywrd, " AUX") == 0) return
!
!   Take special action to output essential data in a compact ASCII form
!
  inquire(unit=hook, opened=opend) 
  if (.not. opend) then
  if (index(text, "END_OF_JOB") /= 0) return
  if (index(text, "Leaving MOPAC") /= 0) return
  open(unit=hook,file=output_fn(:len_trim(output_fn) - 4)//".aux")
  write(hook,"(a)")" START OF MOPAC FILE"
  write(hook,"(a)")" ####################################"
  write(hook,"(a)")" #                                  #"
  write(hook,"(a)")" #       Start of Input data        #"
  write(hook,"(a)")" #                                  #"
  write(hook,"(a)")" ####################################"
  write(hook,"(a,a)")" MOPAC_VERSION=MOPAC2009.",verson
  call fdate (idate) 
  write(hook,"(3a)")" DATE=""",idate,""""
  if (method_mndo) then
    write(hook,"(a)")" METHOD=MNDO"
  else if (method_am1) then
    write(hook,"(a)")" METHOD=AM1"
  else if (method_pm3) then
    write(hook,"(a)")" METHOD=AM1"
  else if (method_pm6) then
    write(hook,"(a)")" METHOD=PM6"
  else if (method_rm1) then
    write(hook,"(a)")" METHOD=RM1"
  else if (method_mndod) then
    write(hook,"(a)")" METHOD=MNDOD"
  end if
  write(hook,"(a,a)")" TITLE=""",koment(:len_trim(koment))//'"'
  line = keywrd
  i = index(line, " AUX")
  j = index(line(i+2:)," ") + i + 1
  line(i:j) = " "
  write(hook,"(a,a)")" KEYWORDS=""",line(:len_trim(line))//'"' 
  if (numat < 334) then
    atoms = "4.4"
    paras = "4.4"
    orbs  = "4.4"
    orbs2 = "6.6"
  else
    atoms = "6.6"
    paras = "6.6"
    orbs  = "6.6"
    orbs2 = "8.8"
  end if 
!
!  All the data used in defining the starting system
!
  write(hook,"(a,i"//atoms//",a)")" ATOM_EL[",numat,"]="
  write(hook,"(40(' ',a2))")(elemnt(nat(i)), i=1,numat)
  write(hook,"(a,i"//atoms//",a)")" ATOM_CORE[",numat,"]="
  write(hook,"(40(' ',i2))")(nint(tore(nat(i))), i=1,numat)
  write(hook,"(a,i"//paras//",a)")" ATOM_X:ANGSTROMS[",3*numat, "]="
  write(hook,"(3f10.4)") ((coord(j,i),j=1,3), i=1,numat)
  if (norbs > 0) then
    write(hook,"(a,i"//orbs//",a)")" AO_ATOMINDEX[",norbs,"]="
    write(hook,"(25i5)")((i,j = nfirst(i),nlast(i)), i = 1, numat)
    write(hook,"(a,i"//orbs//",a)")" ATOM_SYMTYPE[", norbs,"]="
    write(hook,"(40(' ',a2))")&
     ((atorbs(j - nfirst(i) + 1),j = nfirst(i),nlast(i)), i = 1, numat)
    write(hook,"(a,i"//orbs//",a)")" AO_ZETA[",norbs,"]="
!
!   Set up an array to hold all the atomic orbital exponents and principal quantum numbers
!
    j = 1
    do i = 1, numat
      if (nlast(i) - nfirst(i) > -1) then
        work(j) = zs(nat(i))
        iwork(j) = npq(nat(i),1)
        j = j + 1
      end if
      if (nlast(i) - nfirst(i) > 2) then          
        work(j:j + 2) = zp(nat(i))
        iwork(j:j + 2) = npq(nat(i),2)
        j = j + 3
      end if
      if (nlast(i) - nfirst(i) > 7) then          
        work(j:j + 4) = zd(nat(i))
        iwork(j:j + 4) = npq(nat(i),3)
        j = j + 5
      end if
    end do
    write(hook,"(10f8.4)") (work(i), i=1,norbs)
    write(hook,"(a,i"//orbs//",a)")" ATOM_PQN[",norbs,"]="
    write(hook,"(40i2)")(iwork(i), i=1,norbs)
  end if
  if (norbs > 0) write(hook,"(a,i"//orbs//")")" NUM_ELECTRONS=",nelecs
  if (id > 0) then
    write(hook,"(a,i1,a)")" INITIAL_TRANS_VECTS:ANGSTROMS[",id*3,"]="
    write(hook,"(3f9.4)")((tvec(j,i),j=1,3),i=1,id)
    if (density > 1.d-1) write(hook,"(a,d13.6,a)")" DENSITY:G/CM^3=",density
  end if
  write(hook,"(a)")" EMPIRICAL_FORMULA="""//formula(31:len_trim(formula))//""""  
!
!  End of definition of starting system
!
 end if
!
!  Set up options for various types of calculation
!
  geom_opt         = (index(text,"Geometry optimizing") /= 0)
  normal           = (index(text,"Normal output") /= 0)
  force            = (index(text,"Force output") /= 0)
  LMO              = (index(text,"LMO") /= 0)
  int_force_const  = (index(text,"Internal Force Constants") /= 0) 
  error            = (index(text,": ERROR:") /= 0) 
  finished         = (index(text,"Leaving MOPAC") /= 0) 
  end_of_job       = (index(text,"END_OF_JOB") /= 0) 

  if (geom_opt) then
  if (first) then
    i = index(keywrd, " AUX(")
    if (i /= 0) then         
      opt_hook = nint(reada(keywrd,i))
      opt_hook = max(0, min(opt_hook,100))
    else
      opt_hook = hook
    end if
    write(opt_hook,"(a)")" ####################################"
    write(opt_hook,"(a)")" #                                  #"
    write(opt_hook,"(a)")" #      Geometry optimization       #"
    write(opt_hook,"(a)")" #                                  #"
    write(opt_hook,"(a)")" ####################################"
    first = .false.
  end if
!
!  Geometry updated.
!
  write(opt_hook,"(a,sp, d13.6,a)")" HEAT_OF_FORM_UPDATED:KCAL/MOL=",escf
  write(opt_hook,"(a,sp, d13.6,a)")" GRADIENT_UPDATED:KCAL/MOL/ANG=",gnorm
  write(opt_hook,"(a,i"//paras//",a)")" ATOM_X_UPDATED:ANGSTROMS[",3*numat, "]="
  write(opt_hook,"(3f10.4)") ((coord(j,i),j=1,3), i=1,numat)
  if (id > 0) then
    write(opt_hook,"(a,i1,a)")" TRANS_VECTS_UPDATED:ANGSTROMS[",id*3,"]="
    write(opt_hook,"(3f9.4)")((tvec(j,i),j=1,3),i=1,id)
    if (density > 1.d-1) write(opt_hook,"(a,d13.6,a)")" DENSITY:G/CM^3=",density
  end if
  if (opt_hook == 0) call flush (0) 
  return
  else if (normal) then !  Calculated results common to all types of calculation
  write(hook,"(a)")" ####################################"
  write(hook,"(a)")" #                                  #"
  write(hook,"(a)")" #        Final SCF results         #"
  write(hook,"(a)")" #                                  #"
  write(hook,"(a)")" ####################################"

  write(hook,"(a,sp, d13.6,a)")" HEAT_OF_FORMATION:KCAL/MOL=",escf
  write(hook,"(a,sp, d13.6,a)")" ENERGY_ELECTRONIC:EV=",elect
  write(hook,"(a,sp, d13.6,a)")" ENERGY_NUCLEAR:EV=",enuclr
  write(hook,"(a,a)")" POINT_GROUP=",name
  if (id > 0) then
    write(hook,"(a,i1,a)")" TRANS_VECTS:ANGSTROMS[",id*3,"]="
    write(hook,"(3f9.4)")((tvec(j,i),j=1,3),i=1,id)
    if (density > 1.d-1) write(hook,"(a,d13.6,a)")" DENSITY:G/CM^3=",density
    if (Abs(press(1)) > 1.d-20) then
      write(hook,"(a,i1,a)")" RESTRAINING_PRESSURE:GIGAPASCALS[3]="
      write(hook,"(3f11.4)")(press(i),i=1,3)
    end if
  end if
  write(hook,"(a,sp, d13.6, a)")" DIPOLE:DEBYE=",dip(4,3)
  write(hook,"(a,sp, 3d13.5, a)")" DIP_VEC:DEBYE[3]=",(dip(i,3), i = 1, 3)
  if (area > 1.d-6) then
    write(hook,"(a,sp, d13.6,a)")" AREA:SQUARE ANGSTROMS=",area
    write(hook,"(a,sp, d13.6,a)")" VOLUME:CUBIC ANGSTROMS=",cosvol 
    if (Abs(solv_energy) > 1.d-6) write(hook,"(a,sp, d13.6,a)")" DIEL_ENER:EV=",solv_energy
  end if
  write(hook,"(a,i"//paras//",a)")" ATOM_X_OPT:ANGSTROMS[",3*numat, "]="
  write(hook,"(3f10.4)") ((coord(j,i),j=1,3), i=1,numat)
  write(hook,"(a,i"//atoms//",a)")" ATOM_CHARGES[",numat,"]="
  write(hook,"(sp,10f9.5)") (q(i), i=1,numat)
  if (nvar > 0) then
    sum = 0.d0
    do i = 1, nvar
      sum = sum + abs(grad(i))
    end do
    if (sum > 1.d-4) then
      write(hook,"(a,i"//paras//",a)")" GRADIENTS:KCAL/MOL/ANGSTROM[",nvar, "]="
      write(hook,"(10f9.4)") (grad(i), i=1,nvar)
    end if
  end if
!
! Write out the residue letter, if it exists.
!
  do i = 1, numat
    do j = 1, size_mres
      if (index(txtatm(i)(8:11), tyres(j)) > 0) exit
    end do
    if (j <= size_mres) exit
  end do
  if (i <= numat) then
    allocate(letters(numat))
    do i = 1, numat
      do j = 1, size_mres
         if (index(txtatm(i)(8:11), tyres(j)) > 0) exit
      end do
      if (j <= size_mres) then
        letters(i) = tyr(j)
      else
        letters(i) = "?"
      end if
    end do
    write(hook,"(a,i"//atoms//",a)")" RESIDUE_LETTER[",numat,"]="
    write(hook,"(100a1)")(letters(i), i = 1, numat)  
    deallocate(letters)
  end if
  if (mozyme) then
    write(hook,"(a)")" ####################################"
    write(hook,"(a)")" #                                  #"
    write(hook,"(a)")" #     Compressed Bond Orders       #"
    write(hook,"(a)")" #                                  #"
    write(hook,"(a)")" ####################################"
    write(hook,"(a)")" #                               ATOM   BONDED TO ATOMS"
    do i = 1, numat
      ii = iorbs(i)
!
!  Work out all bond orders involving atom i
!
      l = 0
      do j = 1, numat        
        jj = iorbs(j)
        if (i /= j .and. ijbo (i, j) >= 0) then
          kl = ijbo (i, j) + 1
          ku = kl + ii * jj - 1
          sum = 0.d0
          do k = kl, ku
            sum = sum + p(k) ** 2
          end do
          if (sum > 0.05d0) then
            l = l + 1
            work(l) = sum
            iwork(l) = j
          end if
        end if
      end do
!
!  Sort bond orders for atom i into decreasing values
!
      if (l /= 0) then
        do j = 1, l
          sum = 0.d0
          do k = j, l
            if (work(k) > sum) then
              ii = k
              sum = work(k) * (1.d0+1.d-4)
            end if
          end do
          k = iwork(j)
          iwork(j) = iwork(ii)
          iwork(ii) = k
          sum = work(j)
          work(j) = work(ii)
          work(ii) = sum
        end do
        write(hook,"(a,i3.3,a,20i6)")" COMPRESSED_BOND_INDICES[",l + 1,"]=", i, (iwork(j), j=1, l)
        write(hook,"(a,i3.3,a,9x,20f6.3)")" COMPRESSED_BOND_ORDERS_[",l,"]=", (work(j), j=1, l)
        end if
    end do
    if(index(keywrd," LARGE") /= 0) then
      write(hook,"(a,i"//orbs//",a)")" LMO_ENERGY_LEVELS[",norbs,"]="
      write(hook,"(10f9.3)") (eigs(i), i=1,norbs)

      allocate (c_lmo(norbs), ivec(norbs), ic(norbs), c1(norbs))
      write(hook,"(a)")" ####################################"
      write(hook,"(a)")" #                                  #"
      write(hook,"(a)")" #     Compressed LMO vectors       #"
      write(hook,"(a)")" #                                  #"
      write(hook,"(a)")" ####################################"

      do i = 1, noccupied
!
! Expand i'th LMO into uncompressed format
!
        c_lmo = 0.d0
        ii = ncocc(i)
        do j = nncf(i) + 1, nncf(i) + ncf(i)
          jj = icocc(j)
          do k = nfirst(jj), nlast(jj)
            ii = ii + 1
            c_lmo(k) = cocc(ii)
          end do
        end do
        n = 0
        do j = 1,norbs
          if (Abs(c_lmo(j)) > 0.002d0) then
            n = n + 1
            ivec(n) = j
            c_lmo(n) = c_lmo(j)          
          end if
        end do
        !
        !  Re-sequence the coefficients so that the largest is first
        !
        do ii = 1, n
          sum = 0.d0
          do j = 1, n
            if (sum < Abs(c_lmo(j))) then
              sum = Abs(c_lmo(j))
              k = j
            end if
          end do
          ic(ii) = ivec(k)
          c1(ii) = c_lmo(k)
          c_lmo(k) = 0.d0
        end do
        sum = 0.d0
        do j = 1, n
          sum = sum + c1(j)**2
        end do
        phase = 1.d0/sqrt(sum)
        if (c1(1) < 0.d0) phase = -phase
        !
        !  Write out all finite indices.
        !
        write(hook,"(a,i3.3,a)")" LMO_INDICES[",n,"]="
        write(hook,"(20i6)") (ic(ii),ii=1,n)
        write(hook,"(a,i3.3,a)")" LMO_COEFFICIENTS[",n,"]="
        write(hook,"(10f9.4)") (phase*c1(ii),ii=1,n)
      end do
      do i = 1, nvirtual
!
! Expand i'th LMO into uncompressed format
!
        c_lmo = 0.d0
        ii = ncvir(i)
        do j = nnce(i) + 1, nnce(i) + nce(i)
          jj = icvir(j)
          do k = nfirst(jj), nlast(jj)
            ii = ii + 1
            c_lmo(k) = cvir(ii)
          end do
        end do
        n = 0
        do j = 1,norbs
          if (Abs(c_lmo(j)) > 0.002d0) then
            n = n + 1
            ivec(n) = j
            c_lmo(n) = c_lmo(j)          
          end if
        end do
        !
        !  Re-sequence the coefficients so that the largest is first
        !
        do ii = 1, n
          sum = 0.d0
          do j = 1, n
            if (sum < Abs(c_lmo(j))) then
              sum = Abs(c_lmo(j))
              k = j
            end if
          end do
          ic(ii) = ivec(k)
          c1(ii) = c_lmo(k)
          c_lmo(k) = 0.d0
        end do
        sum = 0.d0
        do j = 1, n
          sum = sum + c1(j)**2
        end do
        phase = 1.d0/sqrt(sum)
        if (c1(1) < 0.d0) phase = -phase
        !
        !  Write out all finite indices.
        !
        write(hook,"(a,i3.3,a)")" LMO_INDICES[",n,"]="
        write(hook,"(20i6)") (ic(ii),ii=1,n)
        write(hook,"(a,i3.3,a)")" LMO_COEFFICIENTS[",n,"]="
        write(hook,"(10f9.4)") (phase*c1(ii),ii=1,n)
      end do
      deallocate (c_lmo, ivec, ic, c1)
    else
      write(hook,"(a)")" # To print molecular orbitals, add keyword LARGE  #"
    end if
  else
      allocate(overlap((norbs*(norbs + 1))/2))
      call fill_overlap_matrix(overlap)
      write(hook,"(a,i"//orbs2//",a)")" OVERLAP_MATRIX[",(norbs*(norbs + 1))/2,"]="
      write(hook,"(a)")" #  Lower half triangle only"
      write(hook,"(10f9.4)") (overlap(i), i=1,(norbs*(norbs + 1))/2)
      deallocate (overlap)     
      if (uhf) then
        write(hook,"(a,i"//orbs2//",a)")" ALPHA_EIGENVECTORS[",norbs*norbs,"]="
        write(hook,"(10f9.4)") ((c(j,i), j=1,norbs), i=1,norbs)
        write(hook,"(a,i"//orbs2//",a)")" BETA_EIGENVECTORS[",norbs*norbs,"]="
        write(hook,"(10f9.4)") ((cb(j,i), j=1,norbs), i=1,norbs)
      else
        write(hook,"(a,i"//orbs2//",a)")" EIGENVECTORS[",norbs*norbs,"]="
        write(hook,"(10f9.4)") ((c(j,i), j=1,norbs), i=1,norbs)
      end if
      if (uhf) then
        write(hook,"(a,i"//orbs2//",a)")" ALPHA_DENSITY_MATRIX[",(norbs*(norbs + 1))/2,"]="
        write(hook,"(a)")" #  Lower half triangle only"
        write(hook,"(10f9.4)") (pa(i), i=1,(norbs*(norbs + 1))/2)
        write(hook,"(a,i"//orbs2//",a)")" BETA_DENSITY_MATRIX[",(norbs*(norbs + 1))/2,"]="
        write(hook,"(a)")" #  Lower half triangle only"
        write(hook,"(10f9.4)") (pb(i), i=1,(norbs*(norbs + 1))/2)
      else     
        write(hook,"(a,i"//orbs2//",a)")" TOTAL_DENSITY_MATRIX[",(norbs*(norbs + 1))/2,"]="
        write(hook,"(a)")" #  Lower half triangle only"
        write(hook,"(10f9.4)") (p(i), i=1,(norbs*(norbs + 1))/2)
      end if
      if (index(keywrd, "BOND") /= 0) then
        if (.not. allocated(bondab))  call bonds () 
        write(hook,"(a,i"//orbs2//",a)")" BOND_ORDERS[",(numat*(numat + 1))/2,"]="
        write(hook,"(a)")" #  Lower half triangle only"
        write(hook,"(10f9.4)") (bondab(i), i=1,(numat*(numat + 1))/2)
      end if
      if (jndex(1) == 1) then
        allocate(namo_tmp(norbs))
        namo_tmp = namo
        do i = 1,norbs
          j = index(namo_tmp(i),'"')
          if (j /= 0) namo_tmp(i) = namo(i)(:j - 1)//"''"
        end do
        if (uhf) then
          write(hook,"(a,i"//orbs//",a)")" BETA_M.O.SYMMETRY_LABELS[",norbs,"]="
          write(hook,'(10(i3,a4,1x))') (jndex(i),namo_tmp(i), i=1,norbs)
          call symtrz (c, eigs, 1, .TRUE.) 
          namo_tmp = namo
          do i = 1,norbs
            j = index(namo_tmp(i),'"')
            if (j /= 0) namo_tmp(i) = namo(i)(:j - 1)//"''"
          end do
          write(hook,"(a,i"//orbs//",a)")" ALPHA_M.O.SYMMETRY_LABELS[",norbs,"]="
          write(hook,'(10(i3,a4,1x))') (jndex(i),namo_tmp(i), i=1,norbs)
        else
          write(hook,"(a,i"//orbs//",a)")" M.O.SYMMETRY_LABELS[",norbs,"]="
          write(hook,'(10(i3,a4,1x))') (jndex(i),namo_tmp(i), i=1,norbs)
        end if
        deallocate(namo_tmp)
      end if
      if (uhf) then
        write(hook,"(a,i"//orbs//",a)")" ALPHA_EIGENVALUES[",norbs,"]="
        write(hook,"(10f9.3)") (eigs(i), i=1,norbs)
        write(hook,"(a,i"//orbs//",a)")" BETA_EIGENVALUES[",norbs,"]="
        write(hook,"(10f9.3)") (eigb(i), i=1,norbs)
      else
        write(hook,"(a,i"//orbs//",a)")" EIGENVALUES[",norbs,"]="
        write(hook,"(10f9.3)") (eigs(i), i=1,norbs)
      end if
    end if
!
!   Molecular orbital occupancies
!
    if (uhf) then
        write(hook,"(a,i5.5,a)")" ALPHA_MOLECULAR_ORBITAL_OCCUPANCIES[",norbs,"]="
        write(hook,"(40i2)")(1, i = 1, nalpha),(0, i = nalpha + 1, norbs)
        write(hook,"(a,i5.5,a)")" BETA_MOLECULAR_ORBITAL_OCCUPANCIES[",norbs,"]="
        write(hook,"(40i2)")(1, i = 1, nbeta),(0, i = nbeta + 1, norbs)
    else
      if (nmos == 0) then
        if (mozyme) then
     !     write(hook,"(a,i5)")" NUMBER_OF_OCCUPIED_LMOS=",noccupied
        else
!
!   Simple closed shell RHF
!
          write(hook,"(a,i5.5,a)")" MOLECULAR_ORBITAL_OCCUPANCIES[",norbs,"]="
          write(hook,"(10f7.4)")(2.d0, i = 1, nclose),(0.d0, i = nclose + 1, norbs)
        end if
      else
!
!   RHF-C.I.: Recalculate M.O. occupancies of the active space
!
        write(hook,"(a,i5.5,a)")" MOLECULAR_ORBITAL_OCCUPANCIES[",norbs,"]="
        if (nclose > 0) then
          write(hook,"(a)")" #  Below active space"
          write(hook,"(10f7.4)")(2.d0, i = 1, nclose)
        end if
        write(hook,"(a)")" #  Active space"
        write(hook,"(10f7.4)")(2.d0*occa(i) + deltap(i,i), i = 1, nmos)
        if (nclose + nmos + 1 <= norbs) then
          write(hook,"(a)")" #  Above active space"
          write(hook,"(10f7.4)")(0.d0, i = nclose + nmos + 1, norbs)
        end if
        write(hook,'(''STATE="'',i2,1x,3A)') state_QN, state_spin, &
        state_Irred_Rep(:len_trim(state_Irred_Rep))//'"'       
      end if
    end if
  end if
  if (LMO) then
    if (uhf) then
      if (LMO_alpha) then
        LMO_alpha = .false.
        write(hook,"(a,i"//orbs2//",a)")" ALPHA_LMO_MO[",norbs*nalpha,"]="
        write(hook,"(10f9.4)") ((c(j,i), j=1,norbs), i=1,nalpha)
        write(hook,"(a,i"//orbs//",a)")" ALPHA_LMO_E[",nalpha,"]="
      write(hook,"(10f9.3)") (eigs(i), i=1,nalpha)
      else
        write(hook,"(a,i"//orbs2//",a)")" BETA_LMO_MO[",norbs*nbeta,"]="
        write(hook,"(10f9.4)") ((cb(j,i), j=1,norbs), i=1,nbeta)
        write(hook,"(a,i"//orbs//",a)")" BETA_LMO_E[",nbeta,"]="
      write(hook,"(10f9.3)") (eigb(i), i=1,nbeta)
      end if       
    else
      write(hook,"(a,i"//orbs2//",a)")" LMO_MO[",norbs*nclose,"]="
      write(hook,"(10f9.4)") ((c(j,i), j=1,norbs), i=1,nclose)
      write(hook,"(a,i"//orbs//",a)")" LMO_E[",nclose,"]="
      write(hook,"(10f9.3)") (eigs(i), i=1,nclose)
    end if
  end if
  if(force) then
    write(hook,"(a)")" ####################################"
    write(hook,"(a)")" #                                  #"
    write(hook,"(a)")" #      Normal mode analysis        #"
    write(hook,"(a)")" #                                  #"
    write(hook,"(a)")" ####################################"
    write(hook,"(a,3f13.6,a)")" ROTAT_CONSTS:CM(-1)[3]=",rot
    write(hook,"(a,3f13.6,a)")" PRI_MOM_OF_I:10**(-40)*GRAM-CM**2[3]",xyzmom
    write(hook,"(a,f13.6,a)")" ZERO_POINT_ENERGY:KCAL/MOL=",zpe
    write(hook,"(a,i"//paras//",a)")" VIB._FREQ:CM(-1)[", nvar, "]="
    write(hook,"(10f9.2)") (freq(i), i=1,nvar)
    write(hook,"(a,i"//orbs2//",a)")" NORMAL_MODES[",3*nvar*numat,"]="
    write(hook,"(10f9.4)") (cnorml(i),i = 1,3*nvar*numat)
    j = (3*numat*(3*numat + 1))/2
    write(hook,"(a,i"//orbs2//",a)")" HESSIAN_MATRIX:MILLIDYNES/ANGSTROM[",j,"]="
    write(hook,"(a)")" #  Lower half triangle only"
    write(hook,"(10f9.4)") (fmatrx(i), i=1,j)
    if (jndex(1) == 1) then
      allocate(namo_tmp(nvar))
      namo_tmp = namo
      do i = 1,nvar
        j = index(namo_tmp(i),'"')
        if (j /= 0) namo_tmp(i) = namo(i)(:j - 1)//"''"
      end do
      write(hook,"(a,i"//paras//",a)")" NORMAL_MODE_SYMMETRY_LABELS[",nvar,"]="
      write(hook,'(10(i3,a4,1x))') (jndex(i),namo_tmp(i), i=1,nvar)
      deallocate(namo_tmp)
    end if
    write(hook,"(a,i"//paras//",a)")" VIB._T_DIP:ELECTRONS[", nvar, "]="
    write(hook,"(10f9.3)") (dipt(i), i=1,nvar)
    write(hook,"(a,i"//paras//",a)")" VIB._TRAVEL:ANGSTROMS[", nvar, "]= "
    write(hook,"(10f9.3)") (travel(i), i=1,nvar)
    write(hook,"(a,i"//paras//",a)")" VIB._RED_MASS:AMU[", nvar, "]= "
    write(hook,"(10f9.3)") (redmas(i, 1), i=1,nvar)
    write(hook,"(a,i"//paras//",a)")" VIB._EFF_MASS:AMU[", nvar, "]= "
    write(hook,"(10f9.3)") (min(9999.999d0, max(-999.999d0, redmas(i, 2))), i=1,nvar)
    write(hook,"(a,i"//paras//",a)")" ATOM_X_FORCE:ANGSTROMS[",3*numat, "]="
    write(hook,"(3f10.4)") ((coord(j,i),j=1,3), i=1,numat)
  end if    
  if (int_force_const) then
    write(hook,"(a,i"//paras//",a)")" INT_FORCE_CONSTS:MILLIDYNES/ANGSTROM[",3*numat, "]= "
    write(hook,"(3f10.4)") ((fcint(j,i),j=1,3), i=1,numat) 
    j = 0
    do i = 2, natoms
      if (na(i) /= 0) j = j + 1
    end do
    if (j /= 0) then
      write(hook,"(a,i"//paras//",a)")" INT_COORDS:ANGSTROMS AND DEGREES[",3*numat, "]="
      do i = 1, natoms
        if (na(i) == 0) then
          write(hook,"(3f10.4)") (geo(j,i),j=1,3)
        else
          write(hook,"(3f10.4)") (geo(j,i)*convert(j),j=1,3)
        end if
      end do
      write(hook,"(a,i"//paras//",a)")" CONNECTIVITY[",3*numat, "]="
      write(hook,"(3i5)")(na(i), nb(i), nc(i), i = 1, natoms)
    end if
  end if
  if (error) then
    write(hook,"(a,a)")" ERROR=""",text(17:len_trim(text))//""""
  end if
  if (end_of_job) then
    if (index(text,"JOB ENDED NORM") /= 0) then
      write(hook,"(a,a)")" TERMINATION_MESSAGE=""",text(19:len_trim(text))//'"'
    else
      write(hook,"(a,a)")" ERROR_MESSAGE=""",text(19:len_trim(text))//'"'
    end if
  end if  
  if (finished) then
    write(hook,"(a,f12.2)")" CPU_TIME:SECONDS[1]=",time0
!
!  Don't print processor-independent CPU times for quick jobs - that would waste too much time.
! 
  if (time0 > 10) then
!
!  Deliberately run a time-consuming calculation to work out CPU speed
!  The "j" index is set to use up 1.0 seconds on the development computer.
!  Do NOT change this quantity!
!
    bj = second(2)
    bi = 0.d0
    do j = 1,142083
      do i = 1,1000
        bi = bi + 1.d0/i
      end do
    end do
    bj = second(2) - bj 
    write(hook,"(a,f12.2)")" CPU_TIME:ARBITRARY_UNITS[1]=",time0/bj
    end if
    write(hook,"(a)")" END OF MOPAC FILE"
  end if  
  
  end if
  return
end subroutine version0
subroutine print_conventional_M_O_s(iwrite, compressed, moa_lower, moa_upper, mob_lower, mob_upper, fmt9p4, orbs2)
  use common_arrays_C, only : c, cb
  use molkst_C, only : norbs, uhf
  implicit none
  logical :: compressed
  integer :: iwrite, moa_lower, moa_upper, mob_lower, mob_upper
  character :: fmt9p4*5, orbs2*3
!
!   
  integer :: i, j
  logical :: lnmos, first = .true.
  save :: first
  if (uhf) then
    if (compressed) then      
      lnmos = (moa_upper - moa_lower > -1)
      if (lnmos) then 
        write(iwrite,"(a,2i8)")" SET_OF_ALPHA_MOS=",moa_lower, moa_upper
        if (first .and. (moa_lower > 1 .or. moa_upper < norbs)) write(iwrite,"(a)") &
        " # To print all the molecular orbitals, add keyword LARGE or use MOS=99999 in AUX  #"    
        do i = moa_lower, moa_upper
          call write_comp_vect(iwrite, c(1,i), norbs, 0.002d0, .true., &
          "ALPHA_MO_INDICES","ALPHA_MO_COEFFICIENTS", fmt9p4)
        end do
      end if
      lnmos = (mob_upper - mob_lower > -1)
      if (lnmos) then
        write(iwrite,"(a,2i8)")" SET_OF_BETA_MOS=",mob_lower, mob_upper
        if (first .and. (mob_lower > 1 .or. mob_upper < norbs)) write(iwrite,"(a)") &
        " # To print all the molecular orbitals, add keyword LARGE or use MOS=99999 in AUX  #"  
        do i = mob_lower, mob_upper
          call write_comp_vect(iwrite, cb(1,i), norbs, 0.002d0, .true., &
          "BETA_MO_INDICES","BETA_MO_COEFFICIENTS", fmt9p4)
        end do
      end if
    else
      lnmos = (moa_upper - moa_lower > -1)      
      if (lnmos) then 
        write(iwrite,"(a,2i8)")" SET_OF_ALPHA_MOS=",moa_lower, moa_upper
        if (first .and. (moa_lower > 1 .or. moa_upper < norbs)) write(iwrite,"(a)") &
        " # To print all the molecular orbitals, add keyword LARGE or use MOS=99999 in AUX  #"    
        write(iwrite,"(a,i"//orbs2//",a)")" ALPHA_EIGENVECTORS[",norbs*(moa_upper - moa_lower + 1),"]="
        write(iwrite,"(10f"//fmt9p4//")") ((c(j,i), j=1,norbs), i=moa_lower, moa_upper)
      end if
      lnmos = (mob_upper - mob_lower > -1)
      if (lnmos) then
        write(iwrite,"(a,2i8)")" SET_OF_BETA_MOS=",mob_lower, mob_upper
        if (first .and. (mob_lower > 1 .or. mob_upper < norbs)) write(iwrite,"(a)") &
        " # To print all the molecular orbitals, add keyword LARGE or use MOS=99999 in AUX  #"  
        write(iwrite,"(a,i"//orbs2//",a)")" BETA_EIGENVECTORS[",norbs*(mob_upper - mob_lower + 1),"]="
        write(iwrite,"(10f"//fmt9p4//")") ((cb(j,i), j=1,norbs), i=mob_lower, mob_upper)
      end if
    end if
  else
    lnmos = (moa_upper - moa_lower > -1)  
    if (.not. lnmos) return 
    write(iwrite,"(a,2i8)")" SET_OF_MOS=",moa_lower, moa_upper
    if (first .and. (moa_lower > 1 .or. moa_upper < norbs)) write(iwrite,"(a)") &
    " # To print all the molecular orbitals, add keyword LARGE or use MOS=99999 in AUX  #"    
    if (compressed) then
      do i = moa_lower, moa_upper
        call write_comp_vect(iwrite, c(1,i), norbs, 0.002d0, .true., &
        "MO_INDICES","MO_COEFFICIENTS", fmt9p4)
      end do
    else
      write(iwrite,"(a,i"//orbs2//",a)")" EIGENVECTORS[",norbs*(moa_upper - moa_lower + 1),"]="
      write(iwrite,"(10f"//fmt9p4//")") ((c(j,i), j=1,norbs), i=moa_lower, moa_upper)
    end if
  end if
  first = ( .not. (moa_lower > 1 .or. moa_upper < norbs .or. mob_lower > 1 .or. mob_upper < norbs))
end subroutine print_conventional_M_O_s

Subroutine print_M_O_data(hook, moa_lower, moa_upper, lnmoas, mob_lower, mob_upper, lnmobs, orbs, fmt9p3)
!
! Write out symmetry labels and eigenvalues
!
  use molkst_C, only : norbs, uhf
!
  use symmetry_C, only : jndex, namo
!
  use common_arrays_C, only : c, eigs, eigb
!
  implicit none
  integer, intent (in) :: hook, moa_lower, moa_upper, mob_lower, mob_upper
  logical, intent (in) :: lnmoas, lnmobs

  character, intent (in) :: fmt9p3*5, orbs*3
!
!  Local quantities
!
  integer :: i, j
  character, dimension(:), allocatable :: namo_tmp*4
  logical :: lnmos
  if (jndex(1) == 1) then
    allocate(namo_tmp(norbs))
    namo_tmp = namo
    do i = 1,norbs
      j = index(namo_tmp(i),'"')
      if (j /= 0) namo_tmp(i) = namo(i)(:j - 1)//"''"
    end do      
    if (uhf) then          
      lnmos = (mob_upper - mob_lower > -1)          
      if (lnmos) then
        write(hook,"(a,i"//orbs//",a)")" BETA_M.O.SYMMETRY_LABELS[",mob_upper - mob_lower + 1,"]="
        write(hook,'(10(i4,a4))') (jndex(i),namo_tmp(i), i = mob_lower, mob_upper)
      end if
      lnmos = (moa_upper - moa_lower > -1) 
      if (lnmos) then
      call symtrz (c, eigs, 1, .TRUE.) 
      end if
      namo_tmp = namo
      do i = 1,norbs
        j = index(namo_tmp(i),'"')
        if (j /= 0) namo_tmp(i) = namo(i)(:j - 1)//"''"
      end do
      write(hook,"(a,i"//orbs//",a)")" ALPHA_M.O.SYMMETRY_LABELS[",moa_upper - moa_lower + 1,"]="
      write(hook,'(10(i4,a4))') (jndex(i),namo_tmp(i), i = moa_lower, moa_upper)
    else
      if (lnmoas) then
        write(hook,"(a,i"//orbs//",a)")" M.O.SYMMETRY_LABELS[",moa_upper - moa_lower + 1,"]="
        write(hook,'(10(i4,a4))') (jndex(i),namo_tmp(i), i = moa_lower, moa_upper)
      end if
    end if
    deallocate(namo_tmp)
  end if
  if (uhf) then
    if (lnmoas) then
      write(hook,"(a,i"//orbs//",a)")" ALPHA_EIGENVALUES[",moa_upper - moa_lower + 1,"]="
      write(hook,"(10f"//fmt9p3//")") (eigs(i), i = moa_lower, moa_upper)
    end if
    if (lnmobs) then
      write(hook,"(a,i"//orbs//",a)")" BETA_EIGENVALUES[",mob_upper - mob_lower + 1,"]="
      write(hook,"(10f"//fmt9p3//")") (eigb(i), i = mob_lower, mob_upper)
    end if
  else
    if (lnmoas) then
      write(hook,"(a,i"//orbs//",a)")" EIGENVALUES[",moa_upper - moa_lower + 1,"]="
      write(hook,"(10f"//fmt9p3//")") (eigs(i), i = moa_lower, moa_upper)
    end if
  end if
end subroutine print_M_O_data
subroutine fill_overlap_matrix(overlap)
!
!  Set up an array to hold the overlap matrix
!
  use parameters_C, only : betas, betap, betad, natorb
  use molkst_C, only : norbs, numat
  use common_arrays_C, only : nat, nfirst, h
  implicit none
  double precision, intent (out) :: overlap((norbs*(norbs + 1))/2)
  integer :: i, im1, j, ii, jj, ij, if, jf, ni, nj, norbi, norbj, ifact(norbs + 1)
  double precision :: bi(9), bj(9)
    do i = 1, norbs 
      ifact(i) = (i*(i - 1))/2 
    end do 
    ifact(norbs+1) = (norbs*(norbs + 1))/2 
    overlap = 0.d0
    do i = 1, numat 
      if = nfirst(i) 
      im1 = i - 1 
      bi = betas(nat(i))
      ni = nat(i) 
      bi(1) = betas(ni)*0.5D0 
      bi(2) = betap(ni)*0.5D0 
      bi(3) = bi(2) 
      bi(4) = bi(2) 
      bi(5) = betad(ni)*0.5D0 
      bi(6) = bi(5) 
      bi(7) = bi(5) 
      bi(8) = bi(5) 
      bi(9) = bi(5) 
      norbi = natorb(ni)    
      do j = 1, im1 
        nj = nat(j)
        bj(1) = betas(nj)*0.5D0 
        bj(2) = betap(nj)*0.5D0 
        bj(3) = bj(2) 
        bj(4) = bj(2) 
        bj(5) = betad(nj)*0.5D0 
        bj(6) = bj(5) 
        bj(7) = bj(5) 
        bj(8) = bj(5) 
        bj(9) = bj(5) 
        norbj = natorb(nj) 
        jf = nfirst(j) 
        do ii = 1, norbi
          do jj = 1, norbj
            ij = ((if + ii - 1)*(if + ii - 2))/2 + jf + jj - 1
            overlap(ij) = h(ij)/(bi(ii) + bj(jj))
          end do
        end do
      end do 
    end do 
    overlap(ifact(2:norbs+1)) = 1.D0 
  end subroutine fill_overlap_matrix
