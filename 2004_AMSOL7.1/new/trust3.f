C======================================================================+
      SUBROUTINE TRUST3 (DBG,N,X,F,PAS,SECU,NOOPT,FAIL,G,PRED1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'SIZES.i'
      INCLUDE 'FFILES.i'                                                DJG0496
      DIMENSION X(*),G(*)
C ---------------------------------------------------------------------+
C     TRUST METHODS. LINEAR SEARCH ALONG P, WITH NON NEGATIVE STEPSIZE.
C INPUT (SEE ALSO /OPTMCx/):
C     DBG       .TRUE. TO ACTIVATE PRINTOUT.
C     X(N), F   INITIAL COORDINATES AND ENERGY.
C     P(N)      SEARCH DIRECTION (NORMALIZED TO UNITY).
C     RADIUS    TRUST RADIUS.
C     PAS       INITIAL STEPSIZE (0 < PAS < RADIUS).
C     NOOPT     .TRUE. ==> EXIT AS SOON AS COST FUNCTION DECREASED.
C     G(N)      INITIAL GRADIENT.
C     XOLD(N)   INITIAL COORDINATES.
C     PRED1     1ST ORDER PREDICTION DELTA-COST=PRED1*PAS.
C     LGRAD     .TRUE. IF COST FUNCTION IS GRADIENT NORM.
C OUTPUT
C     PAS     BEST STEPSIZE PRECONIZED. ZERO MEANS DEFINITE FAILURE.
C     X(N)    PRECONIZED COORDINATES.
C     SECU    SECURITY STEPSIZE IF "PAS" TURNS OUT TO BE UNSTABLE.
C     F       SECURITY VALUE OF THE ENERGY, AS FOUND WITH "SECU".
C     G(N)    ASSOCIATED SECURITY GRADIENT.
C     FAIL    .TRUE. IF SCF DIVERGENCE OCCURED (NOT ALWAYS FATAL).
C ---------------------------------------------------------------------+
      COMMON /OPTIMI/ IMP,IMP0
      COMMON /OPTMCR/ H(MAXHES),HV(MAXPAR**2),HB(MAXPAR)
     1               ,XOLD(MAXPAR),GOLD(MAXPAR),POLD(MAXPAR),P(MAXPAR)
     2               ,RADIUS,RHOI,RHOS,GNORM,STEP(0:10),COST(0:10)
     3               ,FOST(0:10),GOST(MAXPAR,0:10)
     4               ,HNEW(MAXHES),BNEW(MAXPAR),VNEW(MAXPAR**2)
     5               ,FBEST,XBEST(MAXPAR),GBEST(MAXPAR)
     6       /OPTMCI/ NEW,KMODE,KSTOP,LM(0:10),MINDEX
     7       /OPTMCL/ LGRAD
      LOGICAL NOOPT,STABOK,DBG,FAIL,LGRAD
      DATA EPS1 /1D-20/
C     TOLERANCE ON STEPSIZE (RELATIVE CHANGE)
      TOLERA=0.9D0
      IF (LGRAD) TOLERA=0.6D0
C     POINT #0
      STEP(0)=0D0
      IF (LGRAD) THEN
         COST(0)=DOT(G,G,N)
         CALL SCOPY (N,G,1,GOST(1,0),1)
      ELSE
         COST(0)=F
      ENDIF
      FOST(0)=F
      IF (DBG) WRITE(JOUT,100) 0,STEP(0),COST(0)
      SLOPE=PRED1
C     POINT #1
      STEP(1)=PAS
      CALL SAXPY (N,PAS,P,1,X,1)
      CALL COMPFG (X,FOST(1),FAIL,G,LGRAD)
      IF (LGRAD) THEN
         COST(1)=DOT(G,G,N)
         CALL SCOPY (N,G,1,GOST(1,1),1)
      ELSE
         COST(1)=FOST(1)
      ENDIF
      IF (DBG) WRITE(JOUT,100) 1,STEP(1),COST(1)
      STABOK=COST(1).LT.COST(0)
      LM(0)=1
      IF (STABOK.AND.NOOPT) GOTO 30
C     POINT #2
      A=(COST(1)-COST(0)-SLOPE*PAS)/PAS**2
      IF (A.LE.EPS1) THEN
         PAS2=2D0*PAS
      ELSE
         PAS2=-0.5D0*SLOPE/A
      ENDIF
      PAS=MAX(PAS*0.1D0,MIN(PAS2,RADIUS))
      IF (STABOK.AND.
     .ABS(STEP(1)-PAS).LT.TOLERA*(ABS(PAS)+EPS1)) GOTO 30
      ICNT=1
      PASINF=MIN(PAS*0.5D0,RADIUS*1D-2)
C     LOOP ON POINT # ICNT (ICNT UP TO 10).
   10 ICNT=ICNT+1
      PASINF=PASINF*0.02D0
      STEP(ICNT)=PAS
      CALL SCOPY (N,XOLD,1,X,1)
      CALL SAXPY (N,PAS,P,1,X,1)
      CALL COMPFG (X,FOST(ICNT),FAIL,G,LGRAD)
      IF (LGRAD) THEN
         COST(ICNT)=DOT(G,G,N)
         CALL SCOPY (N,G,1,GOST(1,ICNT),1)
      ELSE
         COST(ICNT)=FOST(ICNT)
      ENDIF
      IF (DBG) WRITE(JOUT,100) ICNT,STEP(ICNT),COST(ICNT)
C     INTER/EXTRAPOLATE FROM THE THREE LOWEST COSTS FOUND.
      DO 11 I=0,ICNT
   11 LM(I)=I
      DO 13 I=0,2
      DO 12 J=I+1,ICNT
      IF (COST(LM(J)).LT.COST(LM(I))) THEN
         L=LM(I)
         LM(I)=LM(J)
         LM(J)=L
      ENDIF
   12 CONTINUE
   13 CONTINUE
      D=(STEP(LM(0))-STEP(LM(1)))*(STEP(LM(1))-STEP(LM(2)))
     .*(STEP(LM(0))-STEP(LM(2)))
      D=1D0/D
      Z0=COST(LM(0))*(STEP(LM(1))-STEP(LM(2)))
      Z1=COST(LM(1))*(STEP(LM(0))-STEP(LM(2)))
      Z2=COST(LM(2))*(STEP(LM(0))-STEP(LM(1)))
      A=D*(Z0-Z1+Z2)
      IF (A.LE.EPS1) THEN
         PAS=STEP(LM(0))*2D0-STEP(LM(1))
      ELSE
         B=D*(-Z0*(STEP(LM(1))+STEP(LM(2)))
     .        +Z1*(STEP(LM(0))+STEP(LM(2)))
     .        -Z2*(STEP(LM(0))+STEP(LM(1))))
         PAS=-B/(2D0*A)
C        EXTRAPOLATION BOUNDED BY A RATIO=4.
         PSUP=MAX(STEP(LM(0)),STEP(LM(1)),STEP(LM(2)))
         PINF=MIN(STEP(LM(0)),STEP(LM(1)),STEP(LM(2)))
         PAS=MIN(PAS,5D0*PSUP-4D0*PINF)
      ENDIF
C     CHECK TRUST RADIUS.
      PAS=MIN(PAS,RADIUS)
C     BIAS TOWARDS SMALL STEPSIZE IF COST NOT DECREASED
      STABOK=COST(LM(0)).LT.COST(0)
      IF (.NOT.STABOK) PAS=MIN(PAS,STEP(LM(1))*0.2D0)
C     BUT "PAS" MUST REMAIN STRICTLY POSITIVE!
      PAS=MAX(PASINF,PAS)
      IF (STABOK.AND.NOOPT) GOTO 30
      IF (ICNT.EQ.10.OR.(LGRAD.AND.PAS.LE.5D-9)) GOTO 30
C     NEW ATTEMPTED STEP MUST NOT EQUAL A PREVIOUS ONE.
      IF (STABOK) THEN
         TOLER=TOLERA
      ELSE
         TOLER=1D-6
      ENDIF
      DO 20 I=0,ICNT
      IF (ABS(STEP(I)-PAS).LT.TOLER*(ABS(PAS)+EPS1)) GOTO 30
   20 CONTINUE
      GOTO 10
C     END OF SEARCH: STORE THE BEST COST FOUND IN "SECU",
C     RETURN BEST PREDICTED STEP.
   30 IF (.NOT.STABOK) THEN
         PAS=0D0
         IF (DBG) WRITE(JOUT,'(''LINEAR SEARCH FAILED.'')')
      ENDIF
      SECU=STEP(LM(0))-PAS
      F=FOST(LM(0))
      CALL SCOPY (N,GOST(1,LM(0)),1,G,1)
      CALL SCOPY (N,XOLD,1,X,1)
      CALL SAXPY (N,PAS,P,1,X,1)
  100 FORMAT (I3,' STEP',F12.9,' COST=',F22.12)
      END
